import { Address, Abi } from 'abitype';
import { XOR } from 'ts-essentials';
import { RequestArguments } from '@open-rpc/client-js/build/ClientInterface.js';
import { ContainerType, BooleanType, UintBigintType, ByteVectorType, UintNumberType, ByteListType, ValueOf } from '@chainsafe/ssz';
import { Hex as Hex$1 } from 'viem';

/**
 * IAddress type represents an address in hexadecimal format.
 */
type IAddress = `0x${string}`;

/**
 * The hex type.
 *
 * @typedef {Hex}
 */
type Hex = `0x${string}`;

/**
 * The structure representing a processed message.
 *
 * @export
 * @typedef {ProcessedMessage}
 */
type ProcessedMessage = {
    success: boolean;
    data: Hex;
    blockHash: Hex;
    blockNumber: number;
    from: Address;
    gasUsed: bigint;
    gasLimit: bigint;
    hash: Hex;
    seqno: bigint;
    to: Address;
    refundTo: Address;
    bounceTo: Address;
    index?: number;
    value: bigint;
    signature: Hex;
};

/**
 * The block type.
 * Type `T` determines whether the block contains processed messages or just message hashes.
 */
type Block<T = false> = {
    number: number;
    hash: Hex;
    parentHash: Hex;
    inMessagesRoot: Hex;
    receiptsRoot: Hex;
    shardId: number;
    messages: T extends true ? Array<ProcessedMessage> : Array<Hex>;
};
/**
 * The block tag type.
 */
type BlockTag = "latest" | "earliest" | "pending";

/**
 * The args for performing a call to a smart contract.
 *
 * @export
 * @typedef {BaseCallArgs}
 */
type BaseCallArgs = {
    from?: Address;
    to: Address;
    feeCredit?: bigint;
    value?: bigint;
};
/**
 * The args for performing a call with some embedded data.
 *
 * @export
 * @typedef {DataCallArgs}
 */
type DataCallArgs = BaseCallArgs & {
    data: Uint8Array | Hex;
};
/**
 * The args for peforming a call with the specified ABI and function name.
 *
 * @export
 * @typedef {AbiCallArgs}
 */
type AbiCallArgs = BaseCallArgs & {
    abi: Abi;
    functionName: string;
    args?: unknown[];
};
/**
 * The args for performing either a call with embedded data or a call with a specific ABI and function name.
 *
 * @export
 * @typedef {CallArgs}
 */
type CallArgs = XOR<DataCallArgs, AbiCallArgs>;
/**
 * The structure for overriding certain contract params.
 *
 * @export
 * @typedef {ContractOverride}
 */
type ContractOverride = {
    balance?: bigint;
    code?: Uint8Array | Hex;
    seqno?: bigint;
    extSeqno?: bigint;
    state?: unknown;
    stateDiff?: unknown;
};
/**
 * The structure representing an outgoing message (a message created by a smart contract after another message triggers its execution).
 *
 * @export
 * @typedef {OutMessage}
 */
type OutMessage = {
    from?: Address;
    to?: Address;
    feeCredit?: string;
    seqno: string;
    data?: Uint8Array;
    forwardFee?: string;
    coinsUsed: string;
    outMessages: OutMessage[];
    error?: string;
};
/**
 * The structure representing the results of a call.
 *
 * @export
 * @typedef {CallRes}
 */
type CallRes = {
    data: `0x${string}`;
    decodedData?: unknown;
    coinsUsed: string;
    outMessages: OutMessage[];
};

/**
 * The log interface.
 */
type ILog = {
    address: string;
    topics: string[];
    data: string;
    blockNumber: bigint;
};

/**
 * The receipt interface.
 */
type IReceipt = {
    success: boolean;
    gasUsed: string;
    gasPrice?: string;
    bloom: string;
    logs: ILog[];
    messageHash: Hex;
    contractAddress: string;
    blockHash: string;
    blockNumber: number;
    msgIndex: number;
    outMessages: Hex[] | null;
    outputReceipts: (IReceipt | null)[] | null;
    shardId: number;
    includedInMain: boolean;
};
type ProcessedReceipt = Omit<IReceipt, "gasUsed" | "gasPrice" | "outputReceipts"> & {
    gasUsed: bigint;
    gasPrice?: bigint;
    outputReceipts: (ProcessedReceipt | null)[] | null;
};

/**
 * The interface representing the configuration of the HTTP transport.
 */
type IHttpTransportConfig = {
    /**
     * The network endpoint. It is set to the URL of the network node.
     * @example 'http://127.0.0.1:8529'
     */
    endpoint: string;
    /**
     * The request timeout.
     * If the request is not completed within the timeout, it will be rejected.
     * @example 1000
     * @default 20000
     */
    timeout?: number;
};

/**
 * The transport interface.
 */
declare abstract class ITransport {
    /**
     * Sends a request.
     * @param requestObject - The request object. It contains the method and parameters.
     * @returns The response.
     */
    abstract request<T>(requestObject: RequestArguments): Promise<T>;
    /**
     * Connects to the network.
     */
    abstract connect(): void;
    /**
     * Closes the connection to the network.
     */
    abstract closeConnection(): void;
}

/**
 * HttpTransport represents the HTTP transport for connecting to the network.
 *
 * @class HttpTransport
 * @typedef {HttpTransport}
 * @implements {ITransport}
 */
declare class HttpTransport implements ITransport {
    /**
     * The RPC client for the transport.
     *
     * @private
     * @type {RPCClient}
     */
    private rpcClient;
    /**
     * The request timeout.
     *
     * @private
     * @type {number}
     */
    private timeout;
    /**
     * Creates an instance of HttpTransport.
     *
     * @constructor
     * @param {IHttpTransportConfig} config The transport config. See {@link IHttpTransportConfig}.
     */
    constructor(config: IHttpTransportConfig);
    /**
     * Sends a request to the network.
     *
     * @public
     * @async
     * @template T
     * @param {RequestArguments} requestObject The request object.
     * @returns {Promise<T>} The response.
     */
    request<T>(requestObject: RequestArguments): Promise<T>;
    /**
     * Connects to the network.
     *
     * @public
     */
    connect(): void;
    /**
     * Closes the connection to the network.
     *
     * @public
     */
    closeConnection(): void;
}

/**
 * MetaMask transport represents the MetaMask transport for connecting to the network.
 * MetaMask transport can be used in browser only.
 * @class MetaMaskTransport
 * @typedef {MetaMaskTransport}
 * @implements {ITransport}
 */
declare class MetaMaskTransport implements ITransport {
    /**
     * The provider for the transport.
     *
     * @private
     * @type {*}
     */
    private provider;
    /**
     * The request timeout.
     *
     * @private
     * @type {number}
     */
    private timeout;
    /**
     * Creates an instance of MetaMaskTransport.
     *
     * @constructor
     * @param {IHttpTransportConfig} config The transport config.
     */
    constructor(config: IHttpTransportConfig);
    /**
     * Sends a request to the network.
     *
     * @public
     * @async
     * @template T
     * @param {RequestArguments} requestObject The request object.
     * @returns {Promise<T>} The response.
     */
    request<T>(requestObject: RequestArguments): Promise<T>;
    /**
     * Connects to the network.
     *
     * @public
     */
    connect(): void;
    /**
     * Closes the connection to the network.
     *
     * @public
     */
    closeConnection(): void;
}

/**
 * The interface for the Signer class
 */
interface ISigner {
    /**
     * Signs the data.
     * Accepts valid data as an argument and returns the signature.
     * @param data - The data to sign.
     * @example
     * const data = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
     * const recoveredSignature = signer.sign(data);
     */
    sign(data: Uint8Array): Promise<Uint8Array>;
    /**
     * Retrieves the public key.
     * @param shardId - The shard ID.
     * @returns The public key.
     * @example
     * const address = signer.getPublicKey();
     */
    getPublicKey(params: unknown): Promise<Uint8Array>;
    /**
     * Retrieves the address.
     * @param shardId - The shard ID.
     * @returns The address.
     * @example
     * const address = signer.getAddress();
     */
    getAddress(params: unknown): Promise<Uint8Array>;
}

/**
 * The client configuration that is shared between public and private clients.
 */
type IClientBaseConfig = {
    /**
     * The ID of the shard with which the client interacts.
     * @example 1
     */
    shardId?: number;
    /**
     * The transport is used to send requests to the network.
     * @example
     * import { MetaMaskTransport } from '@nilfoundation/niljs';
     *
     * const transport = new MetaMaskTransport();
     *
     * const client = new PublicClient({ transport, shardId: 1 });
     */
    transport: ITransport;
};
/**
 * The type representing the config for the public client.
 */
type IPublicClientConfig = IClientBaseConfig;
/**
 * The type representing the config for the basic wallet.
 */
type IWalletClientConfig = IClientBaseConfig & {
    /**
     * An instance of Signer is used to sign messages.
     * If a Signer is absent from the config, messages should be signed explicitly before being passed to the client.
     * @example
     * import { Signer } from '@nilfoundation/niljs';
     *
     * const signer = new Signer();
     *
     * const client = new WalletClient({
     *  endpoint: 'http://127.0.0.1:8529',
     *  signer: signer
     * })
     */
    signer: ISigner;
};

/**
 * BaseClient is the base class for any client tasked with interacting with =nil;
 * @class BaseClient
 * @typedef {BaseClient}
 */
declare class BaseClient {
    /**
     * The ITransport to be used in the client. See {@link ITransport}.
     *
     * @protected
     * @type {ITransport}
     */
    protected transport: ITransport;
    /**
     * The ID of the shard with which the client needs to interact.
     * The shard with this ID will be used in every call made by the client.
     * @protected
     * @type {number | undefined}
     */
    protected shardId?: number;
    /**
     * Creates an instance of BaseClient.
     * @constructor
     * @param {IClientBaseConfig} config The config to be used in the client. It contains the transport and the shard ID. See {@link IClientBaseConfig}.
     */
    constructor(config: IClientBaseConfig);
    /**
     * Sends a request.
     * @param requestObject The request object. It contains the request method and parameters.
     * @returns The response.
     */
    protected request<T>(requestObject: RequestArguments): Promise<T>;
    /**
     * Returns the shard ID.
     * @returns The shard ID.
     */
    getShardId(): number | undefined;
    /**
     * Sets the shard ID.
     * @param shardId The shard ID.
     * @throws Will throw an error if the provided shard ID is invalid.
     * @example
     * client.setShardId(1);
     */
    setShardId(shardId: number): void;
}

/**
 * PublicClient is a class that allows for interacting with the network via the JSON-RPC API.
 * It provides an abstraction of the connection to =nil;.
 * PublicClient enables using API requests that do not require signing data (or otherwise using one's private key).
 * @example
 * import { PublicClient } from '@nilfoundation/niljs';
 *
 * const client = new PublicClient({
 *   transport: new HttpTransport({
 *     endpoint: RPC_ENDPOINT,
 *   }),
 *   shardId: 1,
 * });
 */
declare class PublicClient extends BaseClient {
    /**
     * Creates an instance of PublicClient.
     *
     * @constructor
     * @param {IPublicClientConfig} config The config to be used in the client. See {@link IPublicClientConfig}.
     */
    constructor(config: IPublicClientConfig);
    /**
     * Returns the block with the given hash.
     * @param hash The hash of the block whose information is requested.
     * @param fullTx The flag that determines whether full transaction information is returned in the output.
     * @param shardId The ID of the shard where the block was generated.
     * @returns Information about the block with the given hash.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *   transport: new HttpTransport({
     *     endpoint: RPC_ENDPOINT,
     *   }),
     *   shardId: 1,
     * });
     *
     * const block = await client.getBlockByHash(HASH);
     */
    getBlockByHash(hash: Hex, fullTx?: boolean, shardId?: number | undefined): Promise<Block<boolean>>;
    /**
     * Returns the block with the given number.
     * @param blockNumber The number of the block whose information is requested.
     * @param fullTx The flag that determines whether full transaction information is returned in the output.
     * @param shardId The ID of the shard where the block was generated.
     * @returns Returns information about a block with the given number.
     * @example
     import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *  endpoint: RPC_ENDPOINT
     * })
     *
     * const block = await client.getBlockByNumber(1);
     */
    getBlockByNumber(blockNumber: Hex, fullTx?: boolean, shardId?: number | undefined): Promise<Block<boolean>>;
    /**
     * Returns the total number of messages recorded in the block with the given number.
     * @param number The number of the block whose information is requested.
     * @returns The number of messages contained within the block.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *  endpoint: RPC_ENDPOINT
     * })
     *
     * const count = await client.getBlockMessageCountByNumber(1);
     *
     */
    getBlockMessageCountByNumber(blockNumber: string, shardId?: number | undefined): Promise<number>;
    /**
     * Returns the total number of messages recorded in the block with the given hash.
     * @param hash The hash of the block whose information is requested.
     * @param shardId The ID of the shard where the block was generated.
     * @returns The number of messages contained within the block.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *  endpoint: RPC_ENDPOINT
     * })
     *
     * const count = await client.getBlockMessageCountByHash(HASH);
     */
    getBlockMessageCountByHash(hash: Hex, shardId?: number | undefined): Promise<number>;
    /**
     * Returns the bytecode of the contract with the given address and at the given block.
     * @param address The address of the account or contract.
     * @param blockNumberOrHash The number/hash of the block.
     * @param shardId The ID of the shard where the block was generated.
     * @returns The bytecode of the contract.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *  endpoint: RPC_ENDPOINT
     * })
     *
     * const code = await client.getCode(ADDRESS, 'latest');
     */
    getCode(address: IAddress, blockNumberOrHash?: Hex | BlockTag): Promise<Uint8Array>;
    /**
     * Returns the transaction count of the account with the given address and at the given block.
     * @param address The address of the account or contract.
     * @param blockNumberOrHash The number/hash of the block.
     * @returns The number of transactions contained within the block.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *  endpoint: RPC_ENDPOINT
     * })
     *
     * const count = await client.getMessageCount(ADDRESS, 'latest');
     *
     */
    getMessageCount(address: IAddress, blockNumberOrHash?: Hex | BlockTag): Promise<number>;
    /**
     * Returns the balance of the given address and at the given block.
     * @param address The address of the account or contract.
     * @param blockNumberOrHash The number/hash of the block.
     * @returns The balance of the address.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *  endpoint: RPC_ENDPOINT
     * })
     *
     * const balance = await client.getBalance(ADDRESS, 'latest');
     */
    getBalance(address: IAddress, blockNumberOrHash?: Hex | BlockTag): Promise<bigint>;
    /**
     * Returns the structure of the internal message with the given hash.
     * @param hash The hash of the message.
     * @param shardId The ID of the shard where the message was recorded.
     * @returns The message whose information is requested.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *  endpoint: RPC_ENDPOINT
     * })
     *
     * const message = await client.getMessageByHash(HASH);
     */
    getMessageByHash(hash: Hex, shardId?: number | undefined): Promise<ProcessedMessage>;
    /**
     * Returns the receipt for the message with the given hash.
     * @param hash The hash of the message.
     * @param shardId The ID of the shard where the message was recorded.
     * @returns The receipt whose structure is requested.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     * endpoint: RPC_ENDPOINT
     * })
     *
     * const receipt = await client.getMessageReceiptByHash(1, HASH);
     */
    getMessageReceiptByHash(hash: Hex, shardId?: number | undefined): Promise<ProcessedReceipt | null>;
    /**
     * Creates a new message or creates a contract for a previously signed message.
     * @param message The encoded bytecode of the message.
     * @returns The hash of the message.
     * @example
     * import { PublicClient } from '@nilfoundation/niljs';
     *
     * const client = new PublicClient({
     *  endpoint: RPC_ENDPOINT
     * })
     *
     * const message = Uint8Array.from(ARRAY);
     */
    sendRawMessage(message: `0x${string}` | Uint8Array): Promise<`0x${string}`>;
    /**
     * Returns the gas price in wei.
     * @returns The gas price.
     */
    getGasPrice(shardId: number): Promise<bigint>;
    /**
     * Returns the gas limit.
     * @returns The gas limit.
     */
    estimateGasLimit(): Promise<bigint>;
    /**
     * Returns the chain ID.
     * @returns The chain ID.
     */
    chainId(): Promise<number>;
    /**
     * Returns all tokens at the given address.
     * @param address The address whose information is requested.
     * @param blockNumberOrHash The number/hash of the block.
     * @returns The list of tokens.
     */
    getCurrencies(address: IAddress, blockNumberOrHash: Hex | BlockTag): Promise<Record<string, bigint>>;
    /**
     * Performs a call to the specified address.
     * @param callArgs The arguments for the call.
     * @param callArgs.from The address of the sender.
     * @param callArgs.to The address of the receiver.
     * @param callArgs.data The data to be sent.
     * @param callArgs.value The value to be sent.
     * @param callArgs.feeCredit The fee credit.
     * @param blockNumberOrHash The number/hash of the block.
     * @param overrides The overrides of state for the chain call.
     */
    call(callArgs: CallArgs, blockNumberOrHash: Hex | BlockTag, overrides?: Record<Address, ContractOverride>): Promise<CallRes>;
}

/**
 * The options for sending a message.
 */
type ISendMessageOptions = {
    /**
     * If true, the message will be validated before sending.
     * If the message is invalid, an error will be thrown.
     * If false, the message will not be validated before sending.
     * @default true
     */
    shouldValidate?: boolean;
};

/**
 * IPrivateKey represents a private key in hexadecimal format.
 */
type IPrivateKey = `0x${string}`;

/**
 * The interface for the configuration object of LocalKeySigner.
 */
type ILocalKeySignerConfig = {
    /**
     * The private key to sign the data.
     * @example '4b3b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f'
     */
    privateKey: IPrivateKey;
    /**
     * The mnemonic to derive the private key.
     * If the mnemonic is provided, privateKey will be ignored.
     */
    mnemonic?: string;
};

/**
 * The LocalKeySigner is a class that allows for signing data with the private key.
 * It uses the secp256k1 curve implementation by the @noble/curves/secp256k1 library.
 * @example
 * import {
 *   LocalECDSAKeySigner,
 *   generateRandomPrivateKey,
 * } from '@nilfoundation/niljs';
 * const signer = new LocalECDSAKeySigner({
 *   privateKey: generateRandomPrivateKey(),
 * });
 */
declare class LocalECDSAKeySigner implements ISigner {
    /**
     * The private key to be used for signing.
     *
     * @private
     * @type {Hex}
     */
    private privateKey;
    /**
     * The public key to be used for signing.
     *
     * @private
     * @type {?Hex}
     */
    private publicKey?;
    /**
     * The wallet address.
     *
     * @private
     * @type {?IAddress}
     */
    private address?;
    /**
     * Creates an instance of LocalECDSAKeySigner.
     *
     * @constructor
     * @param {ILocalKeySignerConfig} config The config for the LocalECDSAKeySigner. See {@link ILocalKeySignerConfig}.
     */
    constructor(config: ILocalKeySignerConfig);
    /**
     * Signs the data.
     *
     * @public
     * @async
     * @param {Uint8Array} data The input data.
     * @returns {Promise<Uint8Array>} The signed data.
     */
    sign(data: Uint8Array): Promise<Uint8Array>;
    /**
     * Retrieves the public key.
     *
     * @public
     * @async
     * @returns {unknown} The publc key of the signer.
     */
    getPublicKey(): Promise<Uint8Array>;
    /**
     * Retrieves the wallet address.
     *
     * @public
     * @async
     * @param {number} shardId The ID of the shard where the wallet is deployed.
     * @returns {unknown} The wallet address.
     */
    getAddress(shardId: number): Promise<Uint8Array>;
}

/**
 * Returns the public key from the private key using the secp256k1 curve.
 */
declare const getPublicKey: (privateKey: IPrivateKey, isCompressed?: boolean) => Hex;
/**
 * Returns the address from the public key.
 * @param publicKey The public key in hex format
 * @param shardId The ID of the shard where the address is located.
 * @returns The address in hex format.
 */
declare const getAddressFromPublicKey: (publicKey: Hex, shardId: number) => IAddress;

/**
 * The interface for the signature. It contains the r, s, and yParity values.
 */
type ISignature = {
    signature: Uint8Array;
};

/**
 * Generate a new private key.
 * @returns The new private key
 * @example
 * const privateKey = generatePrivateKey();
 */
declare const generateRandomPrivateKey: () => IPrivateKey;

/**
 * The MetaMaskSigner is a class that allows for signing data using MetaMask.
 * This signer can only be used inside a browser.
 * @example
 * import { MetaMaskSigner } from '@nilfoundation/niljs';
 *
 * const signer = new MetaMaskSigner();
 */
declare class MetaMaskSigner implements ISigner {
    /**
     * The signer provider.
     *
     * @private
     * @type {*}
     */
    private provider;
    /**
     * Creates an instance of MetaMaskSigner.
     *
     * @constructor
     */
    constructor();
    /**
     * Signs the data.
     *
     * @public
     * @async
     * @param {Uint8Array} data The input data.
     * @returns {unknown} The signed data.
     */
    sign(data: Uint8Array): Promise<Uint8Array>;
    /**
     * Retrieves the wallet address.
     *
     * @public
     * @async
     * @returns {unknown}
     */
    getAddress(): Promise<Uint8Array>;
    /**
     * Retreieves the public key.
     *
     * @public
     * @async
     * @returns {unknown}
     */
    getPublicKey(): Promise<Uint8Array>;
    /**
     * Connects the signer to an existing MetaMask wallet.
     *
     * @public
     * @async
     * @returns {Promise<void>}
     */
    connect(): Promise<void>;
}

/**
 * Converts a hex string to a number.
 * @param hex The hex string to convert.
 * @returns The number representation of the input.
 */
declare const hexToNumber: (hex: Hex) => number;
/**
 * Converts a hex string to a bigint.
 * @param hex The hex string to convert.
 * @returns The bigint representation of the input.
 */
declare const hexToBigInt: (hex: Hex) => bigint;
/**
 * Converts a hex string to a byte array.
 *
 * @param {Hex} hex The hex string to convert.
 * @returns {Uint8Array} The byte array representation of the input.
 */
declare const hexToBytes: (hex: Hex) => Uint8Array;

/**
 * Converts a string, number, bigint, boolean, or ByteArrayType to a hex string.
 * @param value The input to convert.
 * @returns The hex string representation of the input.
 */
declare const toHex: <T extends string | number | bigint | boolean | Uint8Array>(value: T) => Hex;

/**
 * Converts bytes to a string.
 * @param bytes The bytes to convert.
 * @returns The string representation of the input.
 */
declare const bytesToString: (bytes: Uint8Array) => string;
declare const bytesToHex: (bytes: Uint8Array) => Hex;

/**
 * Creates the Poseidon hash of the given bytes.
 * @param byes The bytes to hash.
 * @returns The Poseidon hash.
 */
declare const poseidonHash: (bytes: Uint8Array) => bigint;

/**
 * The SSZ schema for a message object.
 */
declare const SszMessageSchema: ContainerType<{
    deploy: BooleanType;
    feeCredit: UintBigintType;
    to: ByteVectorType;
    chainId: UintNumberType;
    seqno: UintNumberType;
    data: ByteListType;
}>;
/**
 * SSZ schema for a signed message object. Includes auth data in addition to all other message fields.
 */
declare const SszSignedMessageSchema: ContainerType<{
    authData: ByteListType;
    deploy: BooleanType;
    feeCredit: UintBigintType;
    to: ByteVectorType;
    chainId: UintNumberType;
    seqno: UintNumberType;
    data: ByteListType;
}>;

/**
 * The external message type.
 *
 * @typedef {ExternalMessage}
 */
type ExternalMessage = {
    isDeploy: boolean;
    to: Uint8Array;
    chainId: number;
    seqno: number;
    data: Uint8Array;
    authData: Uint8Array;
};

/**
 * IDeployData is a data structure that contains information to deploy a contract.
 */
type deployDataBase = {
    bytecode: Uint8Array | Hex;
    salt: Uint8Array | bigint;
    shard: number;
};
type deployDataWithArgs = deployDataBase & {
    args: unknown[];
    abi: Abi;
};
type deployDataWithoutArgs = deployDataBase & {
    args?: undefined;
    abi?: undefined;
};
type IDeployData$1 = deployDataWithArgs | deployDataWithoutArgs;

/**
 * The envelope for an external message (a message sent by a user, a dApp, etc.)
 *
 * @class ExternalMessageEnvelope
 * @typedef {ExternalMessageEnvelope}
 */
declare class ExternalMessageEnvelope {
    /**
     * The flag that determines whether the external message is a deployment message.
     *
     * @type {boolean}
     */
    isDeploy: boolean;
    /**
     * The destination address of the message.
     *
     * @type {Uint8Array}
     */
    to: Uint8Array;
    /**
     * The chain ID.
     *
     * @type {number}
     */
    chainId: number;
    /**
     * The message sequence number.
     *
     * @type {number}
     */
    seqno: number;
    /**
     * The message data.
     *
     * @type {Uint8Array}
     */
    data: Uint8Array;
    /**
     * The auth data attached to the message.
     *
     * @type {Uint8Array}
     */
    authData: Uint8Array;
    /**
     * Creates an instance of ExternalMessageEnvelope.
     *
     * @constructor
     * @param {ExternalMessage} param0 The object representing the external message.
     * @param {ExternalMessage} param0.isDeploy The flag that determines whether the external message is a deployment message.
     * @param {ExternalMessage} param0.to The destination address of the message.
     * @param {ExternalMessage} param0.chainId The chain ID.
     * @param {ExternalMessage} param0.seqno The message sequence number.
     * @param {ExternalMessage} param0.data The message number.
     * @param {ExternalMessage} param0.authData The auth data attached to the message.
     */
    constructor({ isDeploy, to, chainId, seqno, data, authData, }: ExternalMessage);
    /**
     * Encodes the external message into a Uint8Array.
     *
     * @public
     * @returns {Uint8Array} The encoded external message.
     */
    encode(): Uint8Array;
    /**
     * Provides the hash tree root of the external message.
     *
     * @public
     * @returns {Uint8Array} The hash tree root of the external message.
     */
    hash(): Uint8Array;
    /**
     * Provides the signing hash of the external message.
     *
     * @public
     * @returns {Uint8Array} The signing hash of the external message.
     */
    signingHash(): Uint8Array;
    /**
     * Encodes the external message with its signature.
     *
     * @public
     * @async
     * @param {ISigner} signer The message signer.
     * @returns {Promise<{
     *     raw: Uint8Array;
     *     hash: Uint8Array;
     *   }>} The object containing the encoded message and its hash.
     */
    encodeWithSignature(signer: ISigner): Promise<{
        raw: Uint8Array;
        hash: Uint8Array;
    }>;
    /**
     * Signs the external message.
     *
     * @public
     * @async
     * @param {ISigner} signer The message signer.
     * @returns {Promise<Uint8Array>} The message signature.
     */
    sign(signer: ISigner): Promise<Uint8Array>;
    /**
     * Updates the authentication data in the external message and returns the result.
     *
     * @public
     * @async
     * @param {ISigner} signer The auth data signer.
     * @returns {Promise<Uint8Array>} The signed auth data.
     */
    updateAuthdata(signer: ISigner): Promise<Uint8Array>;
    /**
     * Returns the hex address of the given bytes.
     *
     * @public
     * @returns {`0x${string}`} The hex address.
     */
    hexAddress(): `0x${string}`;
    /**
     * Sends the external message.
     *
     * @public
     * @param {PublicClient} client The client sending the message.
     * @returns {*} The hash of the external message.
     */
    send(client: PublicClient): Promise<`0x${string}`>;
}
/**
 * The envelope for an internal message (a message sent by a smart contract to another smart contract).
 *
 * @class InternalMessageEnvelope
 * @typedef {InternalMessageEnvelope}
 */
declare class InternalMessageEnvelope {
}
/**
 * Creates a new external deployment message.
 *
 * @param {IDeployData} data The message data.
 * @param {number} chainId The chain ID.
 * @returns {ExternalMessageEnvelope} The envelope of the external deployment message.
 * @example
 * import {
     Faucet,
     LocalECDSAKeySigner,
     HttpTransport,
     PublicClient
     WalletV1,
     externalDeploymentMessage,
     generateRandomPrivateKey,
   } from '@nilfoundation/niljs';
 * const signer = new LocalECDSAKeySigner({
     privateKey: generateRandomPrivateKey(),
   });

   const pubkey = await signer.getPublicKey();
 * const chainId = await client.chainId();
 * const deploymentMessage = externalDeploymentMessage(
     {
       salt: 100n,
       shard: 1,
       bytecode: WalletV1.code,
       abi: WalletV1.abi,
       args: [bytesToHex(pubkey)],
     },
     chainId,
   );
 */
declare const externalDeploymentMessage: (data: IDeployData$1, chainId: number) => ExternalMessageEnvelope;
/**
 * Encodes the given external message.
 *
 * @async
 * @param {Omit<ExternalMessage, "authData">} params The external message to be encoded without its auth data.
 * @param {ISigner} signer The message signer.
 * @returns {Promise<{ raw: Uint8Array; hash: Uint8Array }>} The message bytecode and the message hash.
 */
declare const externalMessageEncode: (params: Omit<ExternalMessage, "authData">, signer: ISigner) => Promise<{
    raw: Uint8Array;
    hash: Uint8Array;
}>;

/**
 * The interface for the message object. This object is used to represent a message in the client code.
 * It may differ from the actual message object used inside the network.
 */
interface IMessage extends ValueOf<typeof SszMessageSchema> {
}

/**
 * The signed message interface.
 *
 * @typedef {ISignedMessage}
 */
type ISignedMessage = IMessage & ISignature;

interface Eip1193Provider {
    request(request: {
        method: string;
        params?: Array<any> | Record<string, any>;
    }): Promise<any>;
}
declare global {
    interface Window {
        ethereum?: Eip1193Provider;
    }
}

/**
 * The type that contains the information necessary to deploy a contract.
 */
type IDeployData = {
    /**
     * The compiled contract bytecode.
     */
    bytecode: Hex;
    /**
     * The ID of the shard where the contract should be deployed.
     */
    shardId: number;
    /**
     * The public key of the contract ordering deployment.
     */
    pubkey?: Hex;
    /**
     * The sequence number of the deployment message.
     */
    seqno?: number;
};

/**
 * Checks if the value is a string.
 * @throws Will throw an error if the value is not a hex string.
 * @param value - The value to check.
 * @param message - The message to throw if the value is not a hex string.
 */
declare const assertIsHexString: (value: Hex, message?: string) => void;
/**
 * Checks if the value is a buffer.
 * @throws Will throw an error if value is not a buffer.
 * @param value - The value to check.
 * @param message - The message to throw if the value is not a buffer.
 */
declare const assertIsBuffer: (value: Uint8Array, message?: string) => void;
/**
 * Checks if provided private key is valid. If the value is a hex string with length 32 nothing is returned.
 * @throws Will throw an error if provided private key is invalid.
 * @param privateKey - The private key to check.
 * @param message - The message to throw if the private key is invalid.
 */
declare const assertIsValidPrivateKey: (privateKey: IPrivateKey, message?: string) => void;
/**
 * Checks if the data to deploy contract is valid. If the data is valid, it returns nothing.
 * @throws Will throw an error if the value is not a valid data to deploy contract.
 * @param deployData - The data to validate.
 * @param message - The message to throw if the data is invalid.
 */
declare const assertIsValidDeployData: (deployContractData: IDeployData, message?: string) => void;
/**
 * Checks if the address is valid. If the address is valid, it returns nothing.
 * @param address - The address to check.
 * @param message - The message to throw if the address is invalid.
 */
declare const assertIsAddress: (address: string, message?: string) => void;
/**
 * Checks if the block is valid. If the block is valid, it returns nothing.
 * @param block - The block to check.
 * @param message - The message to throw if the block is invalid.
 */
declare const assertIsValidBlock: (block: Block, message?: string) => void;
/**
 * Checks if the shard id is valid. If the shard id is valid, it returns nothing.
 * @param shardId - The shard id to check.
 */
declare const assertIsValidShardId: (shardId?: number) => void;

/**
 * Checks if the value is a hex string. If the value is a hex string, returns true.
 * Otherwise, returns false.
 * @param value The value to check.
 */
declare const isHexString: (value: unknown) => value is `0x${string}`;
/**
 * Remove the hex prefix from the hex string.
 * @param hex The string whose hex prefix should be removed.
 * @returns The base-16 string.
 */
declare const removeHexPrefix: (str: Hex | string) => string;
/**
 * Add the hex prefix to the hex string.
 * @param hex The string to which the prefix should be added.
 * @returns The string with the prefix.
 */
declare const addHexPrefix: (str: Hex | string) => Hex;
/**
 * Concatenates an array of hex strings. The hex strings are concatenated without the "0x" prefix.
 * The resulting hex string will have the "0x" prefix.
 * @param values - An array of hex strings.
 * @returns The concatenated hex string.
 */
declare const concatHex: (values: readonly Hex[]) => Hex;

/**
 * Checks if the value is an address. If the value is an address, returns true.
 * Otherwise, returns false.
 * @param value The value to check.
 */
declare const isAddress: (value: string) => value is `0x${string}`;
/**
 * Returns the ID of the shard containing the provided address.
 * @param address The address.
 */
declare const getShardIdFromAddress: (address: string) => number;
/**
 * Calculates an address.
 *
 * @param {number} shardId The ID of the shard containing the address.
 * @param {Uint8Array} code The bytecode to be deployed at the address.
 * @param {Uint8Array} salt Arbitrary data for address generation.
 * @returns {Uint8Array} The address.
 */
declare const calculateAddress: (shardId: number, code: Uint8Array, salt: Uint8Array) => Uint8Array;
/**
 * Refines the address.
 *
 * @param {(Uint8Array | `0x`)} address The address to refine.
 * @returns {Uint8Array} The refined address.
 */
declare const refineAddress: (address: Uint8Array | `0x${string}`) => Uint8Array;

/**
 * Checks if the provided block is valid.
 * @param block The block to check.
 * @returns True if the block is valid, false otherwise.
 */
declare const isValidBlock: (block: Block) => block is Block;

/**
 * Makes it so that the client waits until the processing of the message whose hash is passed.
 *
 * @async
 * @param {PublicClient} client The client that must wait for action completion.
 * @param {number} shardId The ID of the shard where the message is processed.
 * @param {Hex} hash The message hash.
 * @returns {unknown}
 * @example
 * await waitTillCompleted(client, 1, hash);
 */
declare const waitTillCompleted: (client: PublicClient, shardId: number, hash: Hex, options?: {
    waitTillMainShard?: boolean;
    interval?: number;
}) => Promise<ProcessedReceipt[]>;

declare const convertEthToWei: (eth: number) => bigint;

/**
 * The interface for the parameters of the BaseError constructor.
 */
type IBaseErrorParameters = {
    /**
     * The flag that indicates if this error is operational.
     * This is useful to differentiate operational errors from programming errors.
     * It is recommended to always set this property to true when creating a custom error class.
     * @default true
     */
    isOperational?: boolean;
    /**
     * The error cause.
     */
    cause?: Error | BaseError;
    /**
     * The path to the documentation of this error.
     */
    docsPath?: string;
};
/**
 * The base class for custom errors.
 */
declare class BaseError extends Error {
    /**
     * The flag that indicates if this error is operational.
     * This is useful to differentiate operational errors from programming errors.
     * It is recommended to always set this property to true when creating a custom error class.
     * @public
     * @type {boolean}
     */
    isOperational: boolean;
    /**
     * The error cause.
     *
     * @public
     * @type {?(Error | BaseError)}
     */
    cause?: Error | BaseError;
    /**
     * The path to the documentation of this error.
     *
     * @public
     * @type {?string}
     */
    docsPath?: string;
    /**
     * Creates an instance of BaseError.
     *
     * @constructor
     * @param {?string} [message] The error message.
     * @param {IBaseErrorParameters} [param0={}] The error params.
     * @param {boolean} [param0.isOperational=true] The flag that determines whether the error is operational.
     * @param {*} param0.cause The error cause.
     * @param {string} param0.docsPath The path to the documentation of this error.
     */
    constructor(message?: string, { isOperational, cause, docsPath }?: IBaseErrorParameters);
}

/**
 * The interface for the parameters of the {@link BlockNotFoundError} constructor.
 */
type BlockNotFoundErrorParameters = {
    blockNumberOrHash: number | Hex;
} & IBaseErrorParameters;
/**
 * The error class for 'block not found' errors.
 * This error is thrown when the requested block is not found.
 */
declare class BlockNotFoundError extends BaseError {
    /**
     * Creates an instance of BlockNotFoundError.
     *
     * @constructor
     * @param {BlockNotFoundErrorParameters} param0 The error params.
     * @param {*} param0.blockNumberOrHash The block number or hash.
     * @param {*} param0....rest The remaining error params, see {@link IBaseErrorParameters}.
     */
    constructor({ blockNumberOrHash, ...rest }: BlockNotFoundErrorParameters);
}

/**
 * The interface for the parameters of the {@link InvalidShardIdError} constructor.
 */
type InvalidShardIdErrorParameters = {
    shardId?: number;
} & IBaseErrorParameters;
/**
 * The error class for invalid shard ID.
 * This error is thrown when the provided shard ID is invalid.
 */
declare class InvalidShardIdError extends BaseError {
    /**
     * Creates an instance of InvalidShardIdError.
     *
     * @constructor
     * @param {InvalidShardIdErrorParameters} param0 The error params.
     * @param {*} param0.shardId The invalid shard ID.
     * @param {*} param0....rest The remaining error params, see {@link IBaseErrorParameters}.
     */
    constructor({ shardId, ...rest }: InvalidShardIdErrorParameters);
}

/**
 * The interface for the parameters of the {@link BlockNotFoundError} constructor.
 */
type IntegerOutOfRangeErrorParameters = {
    max?: number | bigint;
    min: number | bigint;
    value: number | bigint;
} & IBaseErrorParameters;
/**
 * The error class for 'integer out of range' errors.
 * This error is thrown when the requested integer is out of range.
 */
declare class IntegerOutOfRangeError extends BaseError {
    /**
     * Creates an instance of IntegerOutOfRangeError.
     *
     * @constructor
     * @param {IntegerOutOfRangeErrorParameters} param0 The error params.
     * @param {*} param0.max The maximum value.
     * @param {string} param0.min The minimum value.
     */
    constructor({ max, min, value, ...rest }: IntegerOutOfRangeErrorParameters);
}

/**
 * The Faucet is a special contract that is used to top up other contracts in the =nil; devnet.
 *
 * @class Faucet
 * @typedef {Faucet}
 */
declare class Faucet {
    /**
     * The const address of the Faucet contract.
     *
     * @static
     * @type {"0x000100000000000000000000000000000FA00CE7"}
     */
    static address: "0x000100000000000000000000000000000FA00CE7";
    /**
     * The client to be used with the Faucet contract.
     *
     * @private
     * @type {PublicClient}
     */
    private client;
    /**
     * Creates an instance of Faucet.
     *
     * @constructor
     * @param {PublicClient} client
     */
    constructor(client: PublicClient);
    /**
     * Withdraws the specified value to the given address.
     *
     * @deprecated
     * @async
     * @param {Hex} address The address to which the withdrawal should be made.
     * @param {bigint} [value=1000000000000000000n] The value that should be withdrawn to the given address.
     * @param {?number} [seqno] The sequence number of the withdrawal message.
     * @returns {Uint8Array} The hash of the withdrawal message.
     */
    withdrawTo(address: Hex$1, value?: bigint, seqno?: number): Promise<Uint8Array>;
    /**
     * Withdraws the specified value to the given address with retries.
     *
     * @async
     * @param {Hex} address The address to which the withdrawal should be made.
     * @param {bigint} [value=1000000000000000000n] The value that should be withdrawn to the given address.
     * @param {?number} [retry=3] How many times to retry the withdrawal in case of failure.
     * @returns {Uint8Array} The hash of the withdrawal message.
     */
    withdrawToWithRetry(address: Hex$1, value?: bigint, retry?: number): Promise<`0x${string}`>;
}

/**
 * The structure representing a custom currency.
 *
 * @export
 * @typedef {Token}
 */
type Token = {
    id: bigint;
    amount: bigint;
};

type WaletV1BaseConfig = {
    pubkey: Uint8Array | Hex;
    client: PublicClient;
    signer: ISigner;
};
type WalletV1ConfigCalculated = WaletV1BaseConfig & {
    salt: Uint8Array | bigint;
    shardId: number;
    address?: undefined;
};
type WalletV1ConfigAddress = WaletV1BaseConfig & {
    address: Address | Uint8Array;
    salt?: undefined;
    shardId?: undefined;
};
/**
 * Represents the wallet configuration.
 *
 
 * @typedef {WalletV1Config}
 */
type WalletV1Config = WalletV1ConfigCalculated | WalletV1ConfigAddress;
/**
 * Represents the message call params.
 *
 
 * @typedef {CallParams}
 */
type CallParams = {
    to: Address;
    data: Uint8Array;
    value: bigint;
};
type SendBaseMessageParams = {
    to: Address | Uint8Array;
    refundTo?: Address | Uint8Array;
    bounceTo?: Address | Uint8Array;
    data?: Uint8Array | Hex;
    value?: bigint;
    feeCredit: bigint;
    tokens?: Token[];
    deploy?: boolean;
    seqno?: number;
    chainId?: number;
};
type SendDataMessageParams = SendBaseMessageParams & {
    data?: Uint8Array | Hex;
};
type SendAbiMessageParams = SendBaseMessageParams & {
    abi: Abi;
    functionName: string;
    args?: unknown[];
};
/**
 * Represents the params for sending a message.
 *
 * @typedef {SendMessageParams}
 */
type SendMessageParams = XOR<SendDataMessageParams, SendAbiMessageParams>;
type SendSyncBaseMessageParams = {
    to: Address | Uint8Array;
    value: bigint;
    gas: bigint;
    seqno?: number;
};
type SendSyncDataMessageParams = SendSyncBaseMessageParams & {
    data?: Uint8Array | Hex;
};
type SendSyncAbiMessageParams = SendSyncBaseMessageParams & {
    abi: Abi;
    functionName: string;
    args?: unknown[];
};
/**
 * Represents the params for sending a message synchronously.
 *
 * @typedef {SendSyncMessageParams}
 */
type SendSyncMessageParams = XOR<SendSyncDataMessageParams, SendSyncAbiMessageParams>;
/**
 * Represents the params for making a request to the wallet.
 *
 * @typedef {RequestParams}
 */
type RequestParams = {
    data: Uint8Array;
    deploy: boolean;
    seqno?: number;
    chainId?: number;
};
/**
 * Represents the params for deploying a smart contract.
 *
 * @typedef {DeployParams}
 */
type DeployParams = {
    bytecode: Uint8Array | Hex;
    abi?: Abi;
    args?: unknown[];
    salt: Uint8Array | bigint;
    shardId: number;
    feeCredit: bigint;
    value?: bigint;
    seqno?: number;
    chainId?: number;
};

/**
 * WalletV1 is a class used for performing operations on the cluster that require authentication.
 *
 * @class WalletV1
 * @typedef {WalletV1}
 */
declare class WalletV1 {
    /**
     * The wallet bytecode.
     *
     * @static
     * @type {*}
     */
    static code: Uint8Array;
    /**
     * The wallet ABI.
     *
     * @static
     * @type {Abi}
     */
    static abi: Abi;
    /**
     * Calculates the address of the new wallet.
     *
     * @static
     * @param {{
     *     pubKey: Uint8Array;
     *     shardId: number;
     *     salt: Uint8Array | bigint;
     *   }} param0 The object representing the config for address calculation.
     * @param {Uint8Array} param0.pubKey The wallet public key.
     * @param {number} param0.shardId The ID of the shard where the wallet should be deployed.
     * @param {Uint8Array | bigint} param0.salt Arbitrary data change the address.
     * @returns {Uint8Array} The address of the new wallet.
     * @example
     * import {
         LocalECDSAKeySigner,
         WalletV1,
         generateRandomPrivateKey,
       } from '@nilfoundation/niljs';
  
     * const signer = new LocalECDSAKeySigner({
         privateKey: generateRandomPrivateKey(),
       });
  
       const pubkey = await signer.getPublicKey();
  
     * const anotherAddress = WalletV1.calculateWalletAddress({
         pubKey: pubkey,
         shardId: 1,
         salt: 200n,
       });
     */
    static calculateWalletAddress({ pubKey, shardId, salt, }: {
        pubKey: Uint8Array;
        shardId: number;
        salt: Uint8Array | bigint;
    }): Uint8Array;
    /**
     * The wallet public key.
     *
     * @type {Uint8Array}
     */
    pubkey: Uint8Array;
    /**
     * The ID of the shard where the wallet is deployed.
     *
     * @type {number}
     */
    shardId: number;
    /**
     * The client for interacting with the wallet.
     *
     * @type {PublicClient}
     */
    client: PublicClient;
    /**
     * Arbitrary data for changing the wallet address.
     *
     * @type {Uint8Array}
     */
    salt?: Uint8Array;
    /**
     * The wallet signer.
     *
     * @type {ISigner}
     */
    signer: ISigner;
    /**
     * The wallet address.
     *
     * @type {Uint8Array}
     */
    address: Uint8Array;
    /**
     * Creates an instance of WalletV1.
     *
     * @constructor
     * @param {WalletV1Config} param0 The object representing the initial wallet config. See {@link WalletV1Config}.
     * @param {WalletV1Config} param0.pubkey The wallet public key.
     * @param {WalletV1Config} param0.shardId The ID of the shard where the wallet is deployed.
     * @param {WalletV1Config} param0.address The wallet address. If address is not provided it will be calculated with salt.
     * @param {WalletV1Config} param0.client The client for interacting with the wallet.
     * @param {WalletV1Config} param0.salt The arbitrary data for changing the wallet address.
     * @param {WalletV1Config} param0.signer The wallet signer.
     */
    constructor({ pubkey, shardId, address, client, salt, signer, }: WalletV1Config);
    /**
     * Converts the wallet address into a hexadecimal.
     *
     * @returns {String}
     */
    getAddressHex(): `0x${string}`;
    /**
     * Deploys the wallet.
     *
     * @async
     * @param {boolean} [waitTillConfirmation=true] The flag that determines whether the function waits for deployment confirmation before exiting.
     * @returns {Uint8Array} The hash of the deployment transaction.
     * @example
     * import {
         Faucet,
         HttpTransport,
         LocalECDSAKeySigner,
         PublicClient,
         WalletV1,
         generateRandomPrivateKey,
       } from '@nilfoundation/niljs';
     * const client = new PublicClient({
         transport: new HttpTransport({
           endpoint: RPC_ENDPOINT,
         }),
         shardId: 1,
       });
     * const signer = new LocalECDSAKeySigner({
         privateKey: generateRandomPrivateKey(),
       });
     * const faucet = new Faucet(client);
     * await faucet.withdrawTo(walletAddress, 100000n);
     * const pubkey = await signer.getPublicKey();
     * const wallet = new WalletV1({
         pubkey: pubkey,
         salt: 100n,
         shardId: 1,
         client,
         signer,
         address: WalletV1.calculateWalletAddress({
           pubKey: pubkey,
           shardId: 1,
           salt: 100n,
         }),
       });
     * await wallet.selfDeploy(true);
     */
    selfDeploy(waitTillConfirmation?: boolean): Promise<Uint8Array>;
    /**
     * Checks the deployment status.
     *
     * @async
     * @returns {Promise<boolean>} The current deployment status.
     */
    checkDeploymentStatus(): Promise<boolean>;
    /**
     * Performs a request to the wallet.
     *
     * @async
     * @param {RequestParams} requestParams The object representing the request parameters.
     * @param {boolean} [send=true] The flag that determines whether the request is sent when the function is called.
     * @returns {Promise<{ raw: Uint8Array; hash: Uint8Array }>} The message bytecode and hash.
     */
    requestToWallet(requestParams: RequestParams, send?: boolean): Promise<{
        raw: Uint8Array;
        hash: Uint8Array;
    }>;
    /**
     * Send a message via the wallet.
     *
     * @async
     * @param {SendMessageParams} param0 The object representing the message params.
     * @param {SendMessageParams} param0.to The address where the message should be sent.
     * @param {SendMessageParams} param0.refundTo The address where the gas cost should be refunded.
     * @param {SendMessageParams} param0.bounceTo The address where the message value should be refunded in case of failure.
     * @param {SendMessageParams} param0.tokens The tokens to be sent with the message.
     * @param {SendMessageParams} param0.data The message bytecode.
     * @param {SendMessageParams} param0.abi The message abi for encoding.
     * @param {SendMessageParams} param0.functionName The message function name for abi.
     * @param {SendMessageParams} param0.args The message args name for abi.
     * @param {SendMessageParams} param0.deploy The flag that determines whether the message is a deploy message.
     * @param {SendMessageParams} param0.seqno The message sequence number.
     * @param {SendMessageParams} param0.feeCredit The message fee credit for processing message on receiving shard.
     * @param {SendMessageParams} param0.value The message value.
     * @param {SendMessageParams} param0.chainId The message chain id.
     * @returns {unknown} The message hash.
     * @example
     * const anotherAddress = WalletV1.calculateWalletAddress({
     *     pubKey: pubkey,
     *     shardId: 1,
     *     salt: 200n,
     *   });
     * await wallet.sendMessage({
     *     to: anotherAddress,
     *     value: 10n,
     *     gas: 100000n,
     *   });
     */
    sendMessage({ to, refundTo, bounceTo, data, abi, functionName, args, deploy, seqno, feeCredit, value, tokens, chainId, }: SendMessageParams): Promise<`0x${string}`>;
    /**
     * Sets the name of the custom currency that the wallet can own and mint.
     *
     * @async
     * @param {string} The name of the custom currency.
     * @returns {unknown} The message hash.
     * @example
     * const hashMessage = await wallet.setCurrencyName("MY_TOKEN");
     * await waitTillCompleted(client, 1, hashMessage);
     */
    setCurrencyName(name: string): Promise<`0x${string}`>;
    /**
     * Mints the currency that the wallet owns and withdraws it to the wallet.
     * {@link setCurrencyName} has to be called first before minting a currency.
     *
     * @async
     * @param {bigint} The amount to mint.
     * @returns {unknown} The message hash.
     * @example
     * const hashMessage = await wallet.mintCurrency(mintCount);
     * await waitTillCompleted(client, 1, hashMessage);
     */
    mintCurrency(amount: bigint): Promise<`0x${string}`>;
    /**
     * Send a raw signed message via the wallet.
     *
     * @async
     * @param {Uint8Array} rawMessage The message bytecode.
     * @returns {unknown} The message hash.
     */
    sendRawInternalMessage(rawMessage: Uint8Array): Promise<`0x${string}`>;
    /**
     * Deploys a new smart contract via the wallet.
     *
     * @async
     * @param {DeployParams} param0 The object representing the contract deployment params.
     * @param {DeployParams} param0.shardId The ID of the shard where the contract should be deployed.
     * @param {DeployParams} param0.bytecode The contract bytecode.
     * @param {DeployParams} param0.abi The contract ABI.
     * @param {DeployParams} param0.args The arbitrary arguments for deployment.
     * @param {DeployParams} param0.salt The arbitrary data for changing the contract address.
     * @param {DeployParams} param0.value The deployment message value.
     * @param {DeployParams} param0.feeCredit The deployment message fee credit.
     * @param {DeployParams} param0.seqno The deployment message seqno.
     * @param {DeployParams} param0.chainId The deployment message chain id.
     * @returns {unknown} The object containing the deployment message hash and the contract address.
     */
    deployContract({ shardId, bytecode, abi, args, salt, value, feeCredit, seqno, chainId, }: DeployParams): Promise<{
        hash: `0x${string}`;
        address: `0x${string}`;
    }>;
    /**
     * Creates a new message and performs a synchronous call to the specified address.
     *
     * @async
     * @param {SendSyncMessageParams} param0 The object representing the message params.
     * @param {SendSyncMessageParams} param0.to The address where the message should be sent.
     * @param {SendSyncMessageParams} param0.data The message bytecode.
     * @param {SendSyncMessageParams} param0.abi The message abi.
     * @param {SendSyncMessageParams} param0.functionName The message function name for abi.
     * @param {SendSyncMessageParams} param0.args The message args for abi.
     * @param {SendMessageParams} param0.seqno The message sequence number.
     * @param {SendMessageParams} param0.gas The message gas.
     * @param {SendMessageParams} param0.value The message value.
     * @returns {unknown} The message hash.
     * @example
     * const anotherAddress = WalletV1.calculateWalletAddress({
     *     pubKey: pubkey,
     *     shardId: 1,
     *     salt: 200n,
     *   });
     * await wallet.sendMessage({
     *     to: anotherAddress,
     *     value: 10n,
     *     gas: 100000n,
     *   });
     */
    syncSendMessage({ to, data, abi, functionName, args, seqno, gas, value, }: SendSyncMessageParams): Promise<`0x${string}`>;
    /**
     * Returns the wallet balance.
     *
     * @async
     * @returns {unknown} The wallet balance.
     */
    getBalance(): Promise<bigint>;
}

export { type Block, BlockNotFoundError, type BlockTag, type CallParams, type DeployParams, type ExternalMessage, ExternalMessageEnvelope, Faucet, type Hex, HttpTransport, type IClientBaseConfig, type IDeployData$1 as IDeployData, type IHttpTransportConfig, type ILocalKeySignerConfig, type ILog, type IMessage, type IPrivateKey, type IPublicClientConfig, type IReceipt, type ISendMessageOptions, type ISignature, type ISignedMessage, type ISigner, ITransport, type IWalletClientConfig, IntegerOutOfRangeError, InternalMessageEnvelope, InvalidShardIdError, LocalECDSAKeySigner, MetaMaskSigner, MetaMaskTransport, type ProcessedReceipt, PublicClient, type RequestParams, type SendAbiMessageParams, type SendBaseMessageParams, type SendDataMessageParams, type SendMessageParams, type SendSyncAbiMessageParams, type SendSyncBaseMessageParams, type SendSyncDataMessageParams, type SendSyncMessageParams, SszMessageSchema, SszSignedMessageSchema, WalletV1, type WalletV1Config, addHexPrefix, assertIsAddress, assertIsBuffer, assertIsHexString, assertIsValidBlock, assertIsValidDeployData, assertIsValidPrivateKey, assertIsValidShardId, bytesToHex, bytesToString, calculateAddress, concatHex, convertEthToWei, externalDeploymentMessage, externalMessageEncode, generateRandomPrivateKey, getAddressFromPublicKey, getPublicKey, getShardIdFromAddress, hexToBigInt, hexToBytes, hexToNumber, isAddress, isHexString, isValidBlock, poseidonHash, refineAddress, removeHexPrefix, toHex, waitTillCompleted };
