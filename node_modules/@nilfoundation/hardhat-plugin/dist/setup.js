"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupWalletAndClient = setupWalletAndClient;
const niljs_1 = require("@nilfoundation/niljs");
const viem_1 = require("viem");
const conversion_1 = require("./utils/conversion");
const hex_1 = require("./utils/hex");
function isStringArray(accounts) {
    return Array.isArray(accounts);
}
// Type guard to check if a network configuration is HTTP based
function isHttpNetworkConfig(config) {
    return "url" in config;
}
// Function to setup the wallet and client
async function setupWalletAndClient(hre, originalRequest, originalSend) {
    const networkName = "nil";
    const networkConfig = hre.config.networks[networkName];
    // Error handling if the network configuration is not HTTP or is missing
    if (!isHttpNetworkConfig(networkConfig)) {
        throw new Error(`${networkName} is not an HTTP network config or is misconfigured.`);
    }
    // URL is guaranteed to exist and be a string here
    const url = networkConfig.url;
    if (!isStringArray(networkConfig.accounts)) {
        throw new Error("Accounts configuration is not an array of strings.");
    }
    const privateKey = (0, hex_1.ensure0xPrefix)(networkConfig.accounts[0]);
    if (!privateKey) {
        throw new Error("No private key configured for the network.");
    }
    const signer = new niljs_1.LocalECDSAKeySigner({ privateKey });
    const pubKey = await signer.getPublicKey();
    const newWalletSalt = new Uint8Array(32);
    let walletAddress = hre.config.walletAddress
        ? (0, hex_1.ensure0xPrefix)(hre.config.walletAddress)
        : undefined;
    if (!walletAddress) {
        walletAddress = (0, viem_1.bytesToHex)(niljs_1.WalletV1.calculateWalletAddress({
            pubKey,
            shardId: 1,
            salt: newWalletSalt,
        }));
        console.log(`Wallet address not found in configuration.\nGenerated wallet address for current private key: ${walletAddress}`);
    }
    // Set up network components
    const client = new niljs_1.PublicClient({
        transport: new niljs_1.HttpTransport({ endpoint: url }),
        shardId: (0, conversion_1.shardNumber)(walletAddress),
    });
    const faucet = new niljs_1.Faucet(client);
    const config = {
        pubkey: pubKey,
        client,
        signer,
        address: walletAddress,
    };
    const wallet = new niljs_1.WalletV1(config);
    const existingWallet = await client.getCode(walletAddress, "latest");
    if (existingWallet.length === 0) {
        console.log("Deploying new wallet...");
        wallet.salt = newWalletSalt;
        await faucet.withdrawToWithRetry(walletAddress, 1000000000n);
        await wallet.selfDeploy();
        console.log("Deployed new wallet.");
    }
    return {
        hre,
        client,
        wallet,
        faucet,
        signer,
        originalSend,
        originalRequest,
        isRequest: false,
        feeCredit: BigInt(hre.config.feeCredit ?? 5_000_000),
        directTxValue: hre.config.directTxValue
            ? BigInt(hre.config.directTxValue)
            : undefined,
        directTxFeeCredit: hre.config.directTxGasLimit
            ? BigInt(hre.config.directTxGasLimit)
            : undefined,
        debug: hre.config.debug ?? false,
    };
}
