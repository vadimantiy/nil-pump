/**!
 * @nilfoundation/niljs v0.15.0
 *
 * @copyright (c) 2024 =nil; Foundation.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
"use strict";var pe=require("@iden3/js-crypto"),H=require("@chainsafe/persistent-merkle-tree"),b=require("@chainsafe/ssz"),
g=require("@noble/curves/abstract/utils"),o=require("viem"),d=require("tiny-invariant"),S=require("@noble/curves/secp256k1"),
me=require("@scure/bip39"),j=require("@open-rpc/client-js"),V=require("@nilfoundation/smart-contracts/artifacts/Faucet.json"),
v=require("@nilfoundation/smart-contracts/artifacts/Wallet.json");function be(t){var e=Object.create(
null);return t&&Object.keys(t).forEach(function(s){if(s!=="default"){var a=Object.getOwnPropertyDescriptor(
t,s);Object.defineProperty(e,s,a.get?a:{enumerable:!0,get:function(){return t[s]}})}}),e.default=t,Object.
freeze(e)}var x=be(pe),fe="@nilfoundation/niljs",we="=nil; Foundation",ve="0.15.0",Ie={type:"git",url:"\
git+https://github.com/NilFoundation/nil.js.git"},Te="https://github.com/NilFoundation/nil.js.git#RE\
ADME.md",xe="https://github.com/NilFoundation/nil.js/issues",Be={node:">=18.0.0"},qe="module",$e="di\
st/niljs.cjs",Ce="dist/niljs.esm.js",Ae=["dist"],Me="dist/niljs.d.ts",He={".":{types:"./dist/niljs.d\
.ts",import:"./dist/niljs.esm.js",require:"./dist/niljs.cjs"}},Ee=!1,De="Typescript library to inter\
act with the Nil blockchain. Can be used in the browser or in Node.js.",Ne={"test:unit":"CI=true vit\
est -c ./test/vitest.config.ts","test:integration":"CI=true vitest -c ./test/vitest.integration.conf\
ig.ts --isolate false","test:coverage":"CI=true vitest -c ./test/vitest.config.ts --coverage","test:\
examples":"ls ./examples | xargs -I {} tsx ./examples/{}",build:"rimraf dist && rollup -c ./rollup/r\
ollup.config.js --bundleConfigAsCjs",lint:"biome check .","lint:fix":"biome check --write .","lint:t\
ypes":"tsc --noEmit -p tsconfig.json",scripts:"npx --no-install allow-scripts"},ke="MIT",Pe={"@biome\
js/biome":"^1.8.1","@rollup/plugin-node-resolve":"^15.2.3","@vitest/coverage-v8":"^1.6.0",rimraf:"^5\
.0.7",rollup:"^4.17.2","rollup-plugin-dts":"^6.1.0","rollup-plugin-esbuild":"^6.1.1","rollup-plugin-\
filesize":"^10.0.0",tsx:"^4.17.0",typescript:"^5.4.5",vitest:"^1.6.0"},Se={access:"public",registry:"\
https://registry.npmjs.org/"},je={"@chainsafe/persistent-merkle-tree":"^0.7.2","@chainsafe/ssz":"^0.\
16.0","@iden3/js-crypto":"^1.1.0","@nilfoundation/smart-contracts":"^0.1.3","@noble/curves":"^1.4.0",
"@open-rpc/client-js":"^1.8.1","@rollup/plugin-json":"^6.1.0","@scure/bip39":"^1.3.0",abitype:"^1.0.\
2",events:"^3.3.0","tiny-invariant":"^1.3.3","ts-essentials":"^10.0.2",viem:"^2.16.3"},Ue=["nil","bl\
ockchain","client"],Fe={name:fe,author:we,version:ve,repository:Ie,homepage:Te,bugs:xe,engines:Be,type:qe,
main:$e,module:Ce,files:Ae,types:Me,exports:He,sideEffects:Ee,description:De,scripts:Ne,license:ke,devDependencies:Pe,
publishConfig:Se,dependencies:je,keywords:Ue};const z=Fe.version;let E=class oe extends Error{constructor(e,{
isOperational:s=!0,cause:a,docsPath:n}={}){super(),this.name=this.constructor.name,this.isOperational=
s,this.cause=a,this.docsPath=n,this.version=z,this.message=`${e??"An error occured"}
      Name: ${this.name}`,n&&(this.message=`${this.message}
      Docs: see \${this.docsPath}`),this.message=`${this.message}
      Version of the client: ${this.version}`,Object.setPrototypeOf(this,oe.prototype)}};const Re=/^[0-9a-fA-F]+$/,
U=t=>typeof t=="string"&&t.startsWith("0x")&&Re.test(B(t)),B=t=>t.startsWith("0x")?t.slice(2):t,y=t=>`\
0x${B(t)}`,Ke=t=>y(t.reduce((e,s)=>e+s.replace("0x",""),""));const L=t=>{if(t>=48&&t<=57)return t-48;
if(t>=65&&t<=70)return t-55;if(t>=97&&t<=102)return t-87},D=t=>Number.parseInt(B(t),16),$=t=>BigInt(
y(t)),u=t=>{let e=t.slice(2);e.length%2&&(e=`0${e}`);const s=e.length/2,a=new Uint8Array(s);for(let n=0,
r=0;n<s;n++){const i=L(e.charCodeAt(r++)),l=L(e.charCodeAt(r++));if(i===void 0||l===void 0)throw new E(
`Invalid byte sequence ("${e[r-2]}${e[r-1]}" in "${e}").`);a[n]=i*16+l}return a};const Oe=Array.from(
{length:256},(t,e)=>e.toString(16).padStart(2,"0")),We=t=>{let e="";for(let s=0;s<t.length;s++)e+=t.
charCodeAt(s).toString(16);return y(e)},_e=t=>{let e="";for(let s=0;s<t.length;s++)e+=Oe[t[s]];return y(
e)},Ve=t=>{const e=BigInt(t),s=BigInt(Number.MAX_SAFE_INTEGER),a=0;if(typeof t!="bigint"&&(s&&e>s||e<
a))throw new re({max:s,min:a,value:e});return y(e.toString(16))},q=t=>typeof t=="string"?We(t):t instanceof
Uint8Array?_e(t):typeof t=="number"||typeof t=="bigint"?Ve(t):y((t?1:0).toString(16));const ze=new TextDecoder(
"utf8"),Le=t=>ze.decode(t),I=t=>q(t);let F;"default"in x&&typeof x.default=="object"&&x.default!==null&&
"poseidon"in x.default&&typeof x.default.poseidon=="function"?F=x.default.poseidon:F=x.poseidon;const T=t=>F.
hashBytesX(t,16);H.setHasher({digest64(t,e){const s=T(g.concatBytes(t,e)),a=new Uint8Array(32);for(let n=0;n<
32;n++)a[31-n]=Number(s>>BigInt(n*8)&BigInt(255));return a},digest64HashObjects(t,e){const s=T(g.concatBytes(
H.hashObjectToUint8Array(t),H.hashObjectToUint8Array(e))),a=new Uint8Array(32);for(let n=0;n<32;n++)
a[31-n]=Number(s>>BigInt(n*8)&BigInt(255));return H.uint8ArrayToHashObject(a)}});const N={Uint8:new b.
UintNumberType(1),Uint32:new b.UintNumberType(4),Uint64:new b.UintNumberType(8),UintBn256:new b.UintBigintType(
32),Bool:new b.BooleanType},Ge=new b.ByteVectorType(20),R=new b.ContainerType({deploy:N.Bool,feeCredit:N.
UintBn256,to:Ge,chainId:N.Uint64,seqno:N.Uint64,data:new b.ByteListType(24576)}),K=new b.ContainerType(
{...R.fields,authData:new b.ByteListType(256)});const Xe=/^0x[0-9a-fA-F]{40}$/,G=t=>typeof t=="strin\
g"&&Xe.test(t),O=t=>typeof t=="string"?Number.parseInt(t.slice(2,6),16):t[0]<<8|t[1],X=(t,e,s)=>{if(!Number.
isInteger(t))throw new Error("Shard ID must be an integer");if(s.length!==32)throw new Error("Salt m\
ust be 32 bytes");if(e.length===0)throw new Error("Code must not be empty");if(t<0||t>65535)throw new Error(
"Invalid shard ID");const a=new Uint8Array(e.length+32);a.set(e),a.set(s,e.length);const n=T(a),r=g.
numberToBytesBE(t,2),i=g.numberToBytesBE(n,32);return new Uint8Array([...r,...i.slice(14)])},C=t=>{if(typeof t==
"string"){const e=u(t);if(e.length!==20)throw new Error("Invalid address length");return e}if(t.length!==
20)throw new Error("Invalid address length");return t};const J=t=>typeof t=="bigint"?u(y(t.toString(
16).padStart(64,"0"))).slice(0,32):(d(t.length===32,"Salt must be 32 bytes"),t),Je=t=>{const e=typeof t==
"string"?u(t):t;return d(t.length===33,"Invalid pubkey length"),e},Y=({data:t,abi:e,functionName:s,args:a})=>!t&&
!e?"0x":(d(!(t&&e),"ABI and data cannot be provided together"),t?typeof t=="string"?t:I(t):(d(e&&s,"\
ABI and functionName is required"),o.encodeFunctionData({abi:e,functionName:s,args:a||[]})));const k=t=>{
const e=J(t.salt);let s;t.abi?s=u(o.encodeDeployData({abi:t.abi,bytecode:typeof t.bytecode=="string"?
t.bytecode:I(t.bytecode),args:t.args||[]})):s=typeof t.bytecode=="string"?u(t.bytecode):t.bytecode;const a=new Uint8Array(
[...s,...e]),n=X(t.shard,s,e);return{data:a,address:n}};class M{constructor({isDeploy:e,to:s,chainId:a,
seqno:n,data:r,authData:i}){this.isDeploy=e,this.to=s,this.chainId=a,this.seqno=n,this.data=r,this.authData=
i}encode(){return K.serialize({feeCredit:50000000n,seqno:this.seqno,chainId:this.chainId,to:this.to,
data:this.data,deploy:this.isDeploy,authData:this.authData})}hash(){const e=this.encode();return g.numberToBytesBE(
T(e),32)}signingHash(){const e=R.serialize({feeCredit:50000000n,seqno:this.seqno,chainId:this.chainId,
to:this.to,data:this.data,deploy:this.isDeploy});return g.numberToBytesBE(T(e),32)}async encodeWithSignature(e){
const s=await this.sign(e),a=K.serialize({feeCredit:50000000n,seqno:this.seqno,chainId:this.chainId,
to:this.to,data:this.data,deploy:this.isDeploy,authData:s}),n=g.numberToBytesBE(T(a),32);return{raw:a,
hash:n}}async sign(e){return e.sign(this.signingHash())}async updateAuthdata(e){return this.authData=
await this.sign(e),this.authData}hexAddress(){return I(this.to)}send(e){return e.sendRawMessage(this.
encode())}}class Ye{}const Qe=(t,e)=>{const{data:s,address:a}=k(t);return new M({isDeploy:!0,to:a,chainId:e,
seqno:0,data:s,authData:new Uint8Array(0)})},Q=async(t,e)=>await new M({...t,authData:new Uint8Array(
0)}).encodeWithSignature(e);let W=class extends E{constructor({blockNumberOrHash:e,...s}){super(`Blo\
ck not found: ${e}`,{...s})}};const Ze=0;const Z=t=>!0;const et=(t,e)=>{d(U(t),e??`Expected a hex st\
ring but got ${t}`)},tt=(t,e)=>{d(t instanceof Uint8Array,e??`Expected a buffer but got ${t}`)},ee=(t,e)=>{
d(U(t)&&t.length===32*2+2,e??`Expected a valid private key, but got ${t}`)},st=(t,e)=>{const{seqno:s,
pubkey:a,shardId:n}=t;s!==void 0&&d(s>=0,e??`Expected a valid 'seqno' but got ${s}`),a!==void 0&&d(typeof a==
"string",e??`Expected a valid 'pubkey' but got ${a}`),f(n)},at=(t,e)=>{d(G(t),e??`Expected a valid a\
ddress but got ${t}`)},nt=(t,e)=>{d(Z(),e??`Expected a valid block but got ${t}`)},f=t=>{if(!(typeof t==
"number"&&Number.isInteger(t)&&t>=0&&t<65536&&t!==Ze))throw new ne({shardId:t})};let rt=class{constructor(e){
this.transport=e.transport,this.shardId=e.shardId}async request(e){return this.transport.request(e)}getShardId(){
return this.shardId}setShardId(e){f(e),this.shardId=e}};class it extends rt{constructor(e){super(e)}async getBlockByHash(e,s=!1,a=this.
shardId){f(a);try{return await this.request({method:"eth_getBlockByHash",params:[a,e,s]})}catch(n){throw new W(
{blockNumberOrHash:e,cause:n})}}async getBlockByNumber(e,s=!1,a=this.shardId){f(a);try{return await this.
request({method:"eth_getBlockByNumber",params:[a,e,s]})}catch(n){throw new W({blockNumberOrHash:e,cause:n})}}async getBlockMessageCountByNumber(e,s=this.
shardId){return f(s),await this.request({method:"eth_getBlockTransactionCountByNumber",params:[s,e]})}async getBlockMessageCountByHash(e,s=this.
shardId){return f(s),await this.request({method:"eth_getBlockTransactionCountByHash",params:[s,e]})}async getCode(e,s){
const a=await this.request({method:"eth_getCode",params:[e,s??"latest"]});return u(a)}async getMessageCount(e,s){
const a=await this.request({method:"eth_getTransactionCount",params:[e,s??"latest"]});return D(a)}async getBalance(e,s){
const a=await this.request({method:"eth_getBalance",params:[y(e),s??"latest"]});return $(a)}async getMessageByHash(e,s=this.
shardId){f(s);const a=await this.request({method:"eth_getInMessageByHash",params:[s,e]});return{...a,
value:BigInt(a.value),gasLimit:BigInt(a.gasLimit),gasUsed:$(a.gasUsed),seqno:$(a.seqno),index:a.index?
D(a.index):0}}async getMessageReceiptByHash(e,s=this.shardId){f(s);const a=r=>({...r,gasUsed:BigInt(
r.gasUsed),gasPrice:r.gasPrice?BigInt(r.gasPrice):0n,outputReceipts:r.outputReceipts?.map(i=>i===null?
null:a(i))??null}),n=await this.request({method:"eth_getInMessageReceipt",params:[s,y(typeof e=="str\
ing"?e:I(e))]});return n===null?null:a(n)}async sendRawMessage(e){return await this.request({method:"\
eth_sendRawTransaction",params:[typeof e=="string"?e:y(I(e))]})}async getGasPrice(e){const s=await this.
request({method:"eth_gasPrice",params:[e]});return $(s)}async estimateGasLimit(){return BigInt(1e6)}async chainId(){
const e=await this.request({method:"eth_chainId",params:[]});return D(e)}async getCurrencies(e,s){const a=await this.
request({method:"eth_getCurrencies",params:[e,s]}),n={};if(a)for(const[r,i]of Object.entries(a))n[r]=
$(i);return n}async call(e,s,a){let n;e.abi?n=o.encodeFunctionData({abi:e.abi,functionName:e.functionName,
args:e.args||[]}):n=typeof e.data=="string"?e.data:y(I(e.data));const r=[{from:e.from||void 0,to:e.to,
data:n,value:q(e.value||0n),feeCredit:(e.feeCredit||5000000n).toString(10)},s];a&&r.push(a);const i=await this.
request({method:"eth_call",params:r});if(e.abi){const l=o.decodeFunctionResult({abi:e.abi,functionName:e.
functionName,data:i.data});return{...i,decodedData:l}}return i}}const ot=t=>y(q(me.mnemonicToSeedSync(
t).slice(0,32)));const te=(t,e=!1)=>{const s=S.secp256k1.getPublicKey(B(t),e);return y(g.bytesToHex(
s))},se=(t,e)=>{f(e);const s=B(t),a=typeof s=="string"?g.hexToBytes(s):s,n=T(a),r=g.numberToBytesBE(
e,2),i=g.numberToBytesBE(n,32);return q(new Uint8Array([...r,...i.slice(14)]))};class ct{constructor(e){
this.publicKey=void 0,this.address=void 0;const{privateKey:s,mnemonic:a}=e;d(s||a,"Either privateKey\
 or mnemonic must be provided.");const n=a?ot(a):y(s);ee(n),this.privateKey=n}async sign(e){const s=S.
secp256k1.sign(e,B(this.privateKey)),{r:a,s:n,recovery:r}=s;return g.concatBytes(g.numberToBytesBE(a,
32),g.numberToBytesBE(n,32),g.numberToBytesBE(r,1))}async getPublicKey(){if(this.publicKey)return u(
this.publicKey);const e=te(this.privateKey,!0);return this.publicKey=e,u(this.publicKey)}async getAddress(e){
if(this.address)return u(this.address);const s=await this.getPublicKey();return this.address=se(I(s),
e),u(this.address)}}const dt=()=>q(S.secp256k1.utils.randomPrivateKey());let ut=class{constructor(){
d(typeof window<"u","MetaMaskSigner can be used in the browser only"),d(typeof window.ethereum<"u","\
No MetaMask provider found. Please install MetaMask browser extension before using MetaMaskSigner"),
this.provider=window.ethereum}async sign(e){return new Uint8Array(65)}async getAddress(){return new Uint8Array(
20)}async getPublicKey(){return new Uint8Array(33)}async connect(){await this.provider.request({method:"\
eth_requestAccounts"})}};const ae=async(t,e,s,a)=>{const n=a?.interval||1e3,r=a?.waitTillMainShard||
!0,i=[],l=[[e,s]];let p=0;for(;p!==l.length;){const[w,m]=l[p],h=await t.getMessageReceiptByHash(m,w);
if(!h){await new Promise(c=>setTimeout(c,n));continue}if(h.outMessages!==null&&h.outputReceipts&&h.outputReceipts.
filter(c=>c!==null).length!==h.outMessages.length){await new Promise(c=>setTimeout(c,n));continue}if(r&&
h.shardId!==0&&!h.includedInMain){await new Promise(c=>setTimeout(c,n));continue}if(p++,i.push(h),h.
outputReceipts)for(const c of h.outputReceipts)c!==null&&l.push([c.shardId,c.messageHash])}return i};
const lt=t=>BigInt(t*1e18);const ht=t=>{const e=new j.HTTPTransport(t,{headers:{"Client-Version":z}}),
s=new j.RequestManager([e]);return new j.Client(s)};let yt=class{constructor(e){this.rpcClient=ht(e.
endpoint),this.timeout=e.timeout!==void 0?e.timeout:2e4}async request(e){return this.rpcClient.request(
e,this.timeout)}connect(){}closeConnection(){this.rpcClient.close()}};class gt{constructor(e){this.timeout=
e.timeout!==void 0?e.timeout:2e4,d(typeof window<"u","MetaMaskTransport can be used in the browser o\
nly"),d(typeof window.ethereum<"u","No MetaMask provider found. Please install MetaMask browser exte\
nsion before using MetaMaskSigner"),this.provider=window.ethereum}async request(e){return this.provider.
request(e)}connect(){this.provider.request({method:"eth_requestAccounts"})}closeConnection(){}}class pt{}
class ne extends E{constructor({shardId:e,...s}){super(`Expected a valid shardId but got: ${e}`,{...s})}}
class re extends E{constructor({max:e,min:s,value:a,...n}){super(`Number "${a}" is not in safe integ\
er range ${e?`(${s} to ${e})`:`(above ${s})`}`,{...n})}}const ie=class A{constructor(e){this.client=
e}async withdrawTo(e,s=1000000000000000000n,a){const[n,r]=await Promise.all([a??this.client.getMessageCount(
A.address,"latest"),this.client.chainId()]),i=o.encodeFunctionData({abi:V.abi,functionName:"withdraw\
To",args:[e.toLowerCase(),s]}),l=new M({isDeploy:!1,to:u(A.address),chainId:r,seqno:n,data:u(i),authData:new Uint8Array(
0)}),p=l.encode();return await this.client.sendRawMessage(o.bytesToHex(p)),l.hash()}async withdrawToWithRetry(e,s=1000000000000000000n,a=5){
let n=0;for(;n++<a;)try{const[r,i]=await Promise.all([this.client.getMessageCount(A.address,"latest"),
this.client.chainId()]),l=o.encodeFunctionData({abi:V.abi,functionName:"withdrawTo",args:[e.toLowerCase(),
s]}),p=new M({isDeploy:!1,to:u(A.address),chainId:i,seqno:r,data:u(l),authData:new Uint8Array(0)}),w=p.
encode();await this.client.sendRawMessage(o.bytesToHex(w));const m=o.bytesToHex(p.hash()),h=await Promise.
race([new Promise(c=>setTimeout(()=>c([]),1e4)),ae(this.client,O(A.address),m)]);if(h.length===0||h.
some(c=>!c.success))continue;return m}catch(r){if(await new Promise(i=>setTimeout(i,1e3)),n>=a)throw r}
throw new Error("Failed to withdraw to the given address")}};ie.address="0x0001000000000000000000000\
00000000FA00CE7";let mt=ie;const _=class P{static calculateWalletAddress({pubKey:e,shardId:s,salt:a}){
const{address:n}=k({abi:v.abi,bytecode:P.code,args:[o.bytesToHex(e)],salt:a,shard:s});return n}constructor({
pubkey:e,shardId:s,address:a,client:n,salt:r,signer:i}){this.pubkey=Je(e),this.client=n,this.signer=
i,d(!(r&&a),"You should use salt and shard for calculating address or address itself, not both to av\
oid issue."),this.address=a?C(a):P.calculateWalletAddress({pubKey:this.pubkey,shardId:s,salt:r}),r&&
(this.salt=J(r)),this.shardId=O(q(this.address))}getAddressHex(){return o.bytesToHex(this.address)}async selfDeploy(e=!0){
d(typeof this.salt<"u","Salt is required for external deployment. Please provide salt for walelt");const[
s,a]=await Promise.all([await this.client.getBalance(this.getAddressHex(),"latest"),await this.client.
getCode(this.getAddressHex(),"latest").catch(()=>Uint8Array.from([]))]);d(a.length===0,"Contract alr\
eady deployed"),d(s>0n,"Insufficient balance");const{data:n}=k({abi:v.abi,bytecode:P.code,args:[o.bytesToHex(
this.pubkey)],salt:this.salt,shard:this.shardId}),{hash:r}=await this.requestToWallet({data:n,deploy:!0,
seqno:0});if(e)for(;!((await this.client.getCode(this.getAddressHex(),"latest")).length>0);)await new Promise(
i=>setTimeout(i,1e3));return r}async checkDeploymentStatus(){return(await this.client.getCode(this.getAddressHex(),
"latest")).length>0}async requestToWallet(e,s=!0){const[a,n]=await Promise.all([e.seqno??this.client.
getMessageCount(this.getAddressHex(),"latest"),e.chainId??this.client.chainId()]),r=await Q({isDeploy:e.
deploy,to:this.address,chainId:n,seqno:a,data:e.data},this.signer);return s&&await this.client.sendRawMessage(
r.raw),r}async sendMessage({to:e,refundTo:s,bounceTo:a,data:n,abi:r,functionName:i,args:l,deploy:p,seqno:w,
feeCredit:m,value:h,tokens:c,chainId:ce}){const de=o.bytesToHex(C(e)),ue=o.bytesToHex(C(s??this.address)),
le=o.bytesToHex(C(a??this.address)),he=Y({data:n,abi:r,functionName:i,args:l}),ye=o.encodeFunctionData(
{abi:v.abi,functionName:"asyncCall",args:[de,ue,le,m,!!p,c??[],h??0n,he]}),{hash:ge}=await this.requestToWallet(
{data:u(ye),deploy:!1,seqno:w,chainId:ce});return o.bytesToHex(ge)}async setCurrencyName(e){const s=o.
encodeFunctionData({abi:v.abi,functionName:"setCurrencyName",args:[e]}),{hash:a}=await this.requestToWallet(
{data:u(s),deploy:!1});return o.bytesToHex(a)}async mintCurrency(e){return await this.changeCurrencyAmount(
e,!0)}async burnCurrency(e){return await this.changeCurrencyAmount(e,!1)}async changeCurrencyAmount(e,s){
let a="burnCurrency";s&&(a="mintCurrency");const n=o.encodeFunctionData({abi:v.abi,functionName:a,args:[
e]}),{hash:r}=await this.requestToWallet({data:u(n),deploy:!1});return o.bytesToHex(r)}async sendRawInternalMessage(e){
const{hash:s}=await this.requestToWallet({data:e,deploy:!1});return o.bytesToHex(s)}async deployContract({
shardId:e,bytecode:s,abi:a,args:n,salt:r,value:i,feeCredit:l,seqno:p,chainId:w}){let m;a&&n?m={shard:e,
bytecode:s,abi:a,args:n,salt:r}:(d(!(a||n),"ABI and args should be provided together or not provided\
 at all."),m={shard:e,bytecode:s,salt:r});const{data:h,address:c}=k(m);return{hash:await this.sendMessage(
{to:c,refundTo:this.getAddressHex(),data:h,value:i??0n,deploy:!0,feeCredit:l,seqno:p,chainId:w}),address:o.
bytesToHex(c)}}async syncSendMessage({to:e,data:s,abi:a,functionName:n,args:r,seqno:i,gas:l,value:p}){
const w=o.bytesToHex(C(e)),m=Y({data:s,abi:a,functionName:n,args:r}),h=o.encodeFunctionData({abi:v.abi,
functionName:"syncCall",args:[w,l,p,m]}),{hash:c}=await this.requestToWallet({data:u(h),deploy:!1,seqno:i});
return o.bytesToHex(c)}async getBalance(){return this.client.getBalance(this.getAddressHex(),"latest")}};
_.code=u(y(v.evm.bytecode.object)),_.abi=v.abi;let bt=_;exports.BlockNotFoundError=W,exports.ExternalMessageEnvelope=
M,exports.Faucet=mt,exports.HttpTransport=yt,exports.ITransport=pt,exports.IntegerOutOfRangeError=re,
exports.InternalMessageEnvelope=Ye,exports.InvalidShardIdError=ne,exports.LocalECDSAKeySigner=ct,exports.
MetaMaskSigner=ut,exports.MetaMaskTransport=gt,exports.PublicClient=it,exports.SszMessageSchema=R,exports.
SszSignedMessageSchema=K,exports.WalletV1=bt,exports.addHexPrefix=y,exports.assertIsAddress=at,exports.
assertIsBuffer=tt,exports.assertIsHexString=et,exports.assertIsValidBlock=nt,exports.assertIsValidDeployData=
st,exports.assertIsValidPrivateKey=ee,exports.assertIsValidShardId=f,exports.bytesToHex=I,exports.bytesToString=
Le,exports.calculateAddress=X,exports.concatHex=Ke,exports.convertEthToWei=lt,exports.externalDeploymentMessage=
Qe,exports.externalMessageEncode=Q,exports.generateRandomPrivateKey=dt,exports.getAddressFromPublicKey=
se,exports.getPublicKey=te,exports.getShardIdFromAddress=O,exports.hexToBigInt=$,exports.hexToBytes=
u,exports.hexToNumber=D,exports.isAddress=G,exports.isHexString=U,exports.isValidBlock=Z,exports.poseidonHash=
T,exports.refineAddress=C,exports.removeHexPrefix=B,exports.toHex=q,exports.waitTillCompleted=ae;
//# sourceMappingURL=niljs.cjs.map
