/**!
 * @nilfoundation/niljs v0.15.0
 *
 * @copyright (c) 2024 =nil; Foundation.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import*as $ from"@iden3/js-crypto";import{setHasher as be,hashObjectToUint8Array as _,uint8ArrayToHashObject as we}from"@chainsafe/persistent-merkle-tree";
import{UintNumberType as H,UintBigintType as ve,BooleanType as Ie,ByteVectorType as xe,ContainerType as z,
ByteListType as L}from"@chainsafe/ssz";import{concatBytes as E,numberToBytesBE as m,bytesToHex as $e,
hexToBytes as Ce}from"@noble/curves/abstract/utils";import{encodeFunctionData as w,encodeDeployData as Be,
decodeFunctionResult as qe,bytesToHex as g}from"viem";import c from"tiny-invariant";import{secp256k1 as U}from"@noble/curves/secp256k1";
import{mnemonicToSeedSync as Ae}from"@scure/bip39";import{HTTPTransport as Te,RequestManager as Me,Client as Ne}from"@open-rpc/client-js";
import G from"@nilfoundation/smart-contracts/artifacts/Faucet.json";import v from"@nilfoundation/smart-contracts/artifacts/Wallet.json";
var ke="@nilfoundation/niljs",De="=nil; Foundation",Se="0.15.0",Pe={type:"git",url:"git+https://gith\
ub.com/NilFoundation/nil.js.git"},He="https://github.com/NilFoundation/nil.js.git#README.md",Ee="htt\
ps://github.com/NilFoundation/nil.js/issues",Ue={node:">=18.0.0"},je="module",Re="dist/niljs.cjs",Ke="\
dist/niljs.esm.js",We=["dist"],Fe="dist/niljs.d.ts",Oe={".":{types:"./dist/niljs.d.ts",import:"./dis\
t/niljs.esm.js",require:"./dist/niljs.cjs"}},Ve=!1,_e="Typescript library to interact with the Nil b\
lockchain. Can be used in the browser or in Node.js.",ze={"test:unit":"CI=true vitest -c ./test/vite\
st.config.ts","test:integration":"CI=true vitest -c ./test/vitest.integration.config.ts --isolate fa\
lse","test:coverage":"CI=true vitest -c ./test/vitest.config.ts --coverage","test:examples":"ls ./ex\
amples | xargs -I {} tsx ./examples/{}",build:"rimraf dist && rollup -c ./rollup/rollup.config.js --\
bundleConfigAsCjs",lint:"biome check .","lint:fix":"biome check --write .","lint:types":"tsc --noEmi\
t -p tsconfig.json",scripts:"npx --no-install allow-scripts"},Le="MIT",Ge={"@biomejs/biome":"^1.8.1",
"@rollup/plugin-node-resolve":"^15.2.3","@vitest/coverage-v8":"^1.6.0",rimraf:"^5.0.7",rollup:"^4.17\
.2","rollup-plugin-dts":"^6.1.0","rollup-plugin-esbuild":"^6.1.1","rollup-plugin-filesize":"^10.0.0",
tsx:"^4.17.0",typescript:"^5.4.5",vitest:"^1.6.0"},Xe={access:"public",registry:"https://registry.np\
mjs.org/"},Ye={"@chainsafe/persistent-merkle-tree":"^0.7.2","@chainsafe/ssz":"^0.16.0","@iden3/js-cr\
ypto":"^1.1.0","@nilfoundation/smart-contracts":"^0.1.3","@noble/curves":"^1.4.0","@open-rpc/client-\
js":"^1.8.1","@rollup/plugin-json":"^6.1.0","@scure/bip39":"^1.3.0",abitype:"^1.0.2",events:"^3.3.0",
"tiny-invariant":"^1.3.3","ts-essentials":"^10.0.2",viem:"^2.16.3"},Je=["nil","blockchain","client"],
Qe={name:ke,author:De,version:Se,repository:Pe,homepage:He,bugs:Ee,engines:Ue,type:je,main:Re,module:Ke,
files:We,types:Fe,exports:Oe,sideEffects:Ve,description:_e,scripts:ze,license:Le,devDependencies:Ge,
publishConfig:Xe,dependencies:Ye,keywords:Je};const X=Qe.version;let N=class le extends Error{constructor(e,{
isOperational:s=!0,cause:a,docsPath:n}={}){super(),this.name=this.constructor.name,this.isOperational=
s,this.cause=a,this.docsPath=n,this.version=X,this.message=`${e??"An error occured"}
      Name: ${this.name}`,n&&(this.message=`${this.message}
      Docs: see \${this.docsPath}`),this.message=`${this.message}
      Version of the client: ${this.version}`,Object.setPrototypeOf(this,le.prototype)}};const Ze=/^[0-9a-fA-F]+$/,
j=t=>typeof t=="string"&&t.startsWith("0x")&&Ze.test(C(t)),C=t=>t.startsWith("0x")?t.slice(2):t,u=t=>`\
0x${C(t)}`,et=t=>u(t.reduce((e,s)=>e+s.replace("0x",""),""));const Y=t=>{if(t>=48&&t<=57)return t-48;
if(t>=65&&t<=70)return t-55;if(t>=97&&t<=102)return t-87},k=t=>Number.parseInt(C(t),16),q=t=>BigInt(
u(t)),d=t=>{let e=t.slice(2);e.length%2&&(e=`0${e}`);const s=e.length/2,a=new Uint8Array(s);for(let n=0,
r=0;n<s;n++){const i=Y(e.charCodeAt(r++)),l=Y(e.charCodeAt(r++));if(i===void 0||l===void 0)throw new N(
`Invalid byte sequence ("${e[r-2]}${e[r-1]}" in "${e}").`);a[n]=i*16+l}return a};const tt=Array.from(
{length:256},(t,e)=>e.toString(16).padStart(2,"0")),st=t=>{let e="";for(let s=0;s<t.length;s++)e+=t.
charCodeAt(s).toString(16);return u(e)},at=t=>{let e="";for(let s=0;s<t.length;s++)e+=tt[t[s]];return u(
e)},nt=t=>{const e=BigInt(t),s=BigInt(Number.MAX_SAFE_INTEGER),a=0;if(typeof t!="bigint"&&(s&&e>s||e<
a))throw new ce({max:s,min:a,value:e});return u(e.toString(16))},B=t=>typeof t=="string"?st(t):t instanceof
Uint8Array?at(t):typeof t=="number"||typeof t=="bigint"?nt(t):u((t?1:0).toString(16));const rt=new TextDecoder(
"utf8"),it=t=>rt.decode(t),I=t=>B(t);let R;"default"in $&&typeof $.default=="object"&&$.default!==null&&
"poseidon"in $.default&&typeof $.default.poseidon=="function"?R=$.default.poseidon:R=$.poseidon;const x=t=>R.
hashBytesX(t,16);be({digest64(t,e){const s=x(E(t,e)),a=new Uint8Array(32);for(let n=0;n<32;n++)a[31-
n]=Number(s>>BigInt(n*8)&BigInt(255));return a},digest64HashObjects(t,e){const s=x(E(_(t),_(e))),a=new Uint8Array(
32);for(let n=0;n<32;n++)a[31-n]=Number(s>>BigInt(n*8)&BigInt(255));return we(a)}});const D={Uint8:new H(
1),Uint32:new H(4),Uint64:new H(8),UintBn256:new ve(32),Bool:new Ie},ot=new xe(20),K=new z({deploy:D.
Bool,feeCredit:D.UintBn256,to:ot,chainId:D.Uint64,seqno:D.Uint64,data:new L(24576)}),W=new z({...K.fields,
authData:new L(256)});const ct=/^0x[0-9a-fA-F]{40}$/,J=t=>typeof t=="string"&&ct.test(t),F=t=>typeof t==
"string"?Number.parseInt(t.slice(2,6),16):t[0]<<8|t[1],Q=(t,e,s)=>{if(!Number.isInteger(t))throw new Error(
"Shard ID must be an integer");if(s.length!==32)throw new Error("Salt must be 32 bytes");if(e.length===
0)throw new Error("Code must not be empty");if(t<0||t>65535)throw new Error("Invalid shard ID");const a=new Uint8Array(
e.length+32);a.set(e),a.set(s,e.length);const n=x(a),r=m(t,2),i=m(n,32);return new Uint8Array([...r,
...i.slice(14)])},A=t=>{if(typeof t=="string"){const e=d(t);if(e.length!==20)throw new Error("Invali\
d address length");return e}if(t.length!==20)throw new Error("Invalid address length");return t};const Z=t=>typeof t==
"bigint"?d(u(t.toString(16).padStart(64,"0"))).slice(0,32):(c(t.length===32,"Salt must be 32 bytes"),
t),dt=t=>{const e=typeof t=="string"?d(t):t;return c(t.length===33,"Invalid pubkey length"),e},ee=({
data:t,abi:e,functionName:s,args:a})=>!t&&!e?"0x":(c(!(t&&e),"ABI and data cannot be provided togeth\
er"),t?typeof t=="string"?t:I(t):(c(e&&s,"ABI and functionName is required"),w({abi:e,functionName:s,
args:a||[]})));const S=t=>{const e=Z(t.salt);let s;t.abi?s=d(Be({abi:t.abi,bytecode:typeof t.bytecode==
"string"?t.bytecode:I(t.bytecode),args:t.args||[]})):s=typeof t.bytecode=="string"?d(t.bytecode):t.bytecode;
const a=new Uint8Array([...s,...e]),n=Q(t.shard,s,e);return{data:a,address:n}};class M{constructor({
isDeploy:e,to:s,chainId:a,seqno:n,data:r,authData:i}){this.isDeploy=e,this.to=s,this.chainId=a,this.
seqno=n,this.data=r,this.authData=i}encode(){return W.serialize({feeCredit:50000000n,seqno:this.seqno,
chainId:this.chainId,to:this.to,data:this.data,deploy:this.isDeploy,authData:this.authData})}hash(){
const e=this.encode();return m(x(e),32)}signingHash(){const e=K.serialize({feeCredit:50000000n,seqno:this.
seqno,chainId:this.chainId,to:this.to,data:this.data,deploy:this.isDeploy});return m(x(e),32)}async encodeWithSignature(e){
const s=await this.sign(e),a=W.serialize({feeCredit:50000000n,seqno:this.seqno,chainId:this.chainId,
to:this.to,data:this.data,deploy:this.isDeploy,authData:s}),n=m(x(a),32);return{raw:a,hash:n}}async sign(e){
return e.sign(this.signingHash())}async updateAuthdata(e){return this.authData=await this.sign(e),this.
authData}hexAddress(){return I(this.to)}send(e){return e.sendRawMessage(this.encode())}}class lt{}const ht=(t,e)=>{
const{data:s,address:a}=S(t);return new M({isDeploy:!0,to:a,chainId:e,seqno:0,data:s,authData:new Uint8Array(
0)})},te=async(t,e)=>await new M({...t,authData:new Uint8Array(0)}).encodeWithSignature(e);let O=class extends N{constructor({
blockNumberOrHash:e,...s}){super(`Block not found: ${e}`,{...s})}};const ut=0;const se=t=>!0;const gt=(t,e)=>{
c(j(t),e??`Expected a hex string but got ${t}`)},pt=(t,e)=>{c(t instanceof Uint8Array,e??`Expected a\
 buffer but got ${t}`)},ae=(t,e)=>{c(j(t)&&t.length===32*2+2,e??`Expected a valid private key, but g\
ot ${t}`)},yt=(t,e)=>{const{seqno:s,pubkey:a,shardId:n}=t;s!==void 0&&c(s>=0,e??`Expected a valid 's\
eqno' but got ${s}`),a!==void 0&&c(typeof a=="string",e??`Expected a valid 'pubkey' but got ${a}`),f(
n)},mt=(t,e)=>{c(J(t),e??`Expected a valid address but got ${t}`)},ft=(t,e)=>{c(se(),e??`Expected a \
valid block but got ${t}`)},f=t=>{if(!(typeof t=="number"&&Number.isInteger(t)&&t>=0&&t<65536&&t!==ut))
throw new oe({shardId:t})};let bt=class{constructor(e){this.transport=e.transport,this.shardId=e.shardId}async request(e){
return this.transport.request(e)}getShardId(){return this.shardId}setShardId(e){f(e),this.shardId=e}};
class wt extends bt{constructor(e){super(e)}async getBlockByHash(e,s=!1,a=this.shardId){f(a);try{return await this.
request({method:"eth_getBlockByHash",params:[a,e,s]})}catch(n){throw new O({blockNumberOrHash:e,cause:n})}}async getBlockByNumber(e,s=!1,a=this.
shardId){f(a);try{return await this.request({method:"eth_getBlockByNumber",params:[a,e,s]})}catch(n){
throw new O({blockNumberOrHash:e,cause:n})}}async getBlockMessageCountByNumber(e,s=this.shardId){return f(
s),await this.request({method:"eth_getBlockTransactionCountByNumber",params:[s,e]})}async getBlockMessageCountByHash(e,s=this.
shardId){return f(s),await this.request({method:"eth_getBlockTransactionCountByHash",params:[s,e]})}async getCode(e,s){
const a=await this.request({method:"eth_getCode",params:[e,s??"latest"]});return d(a)}async getMessageCount(e,s){
const a=await this.request({method:"eth_getTransactionCount",params:[e,s??"latest"]});return k(a)}async getBalance(e,s){
const a=await this.request({method:"eth_getBalance",params:[u(e),s??"latest"]});return q(a)}async getMessageByHash(e,s=this.
shardId){f(s);const a=await this.request({method:"eth_getInMessageByHash",params:[s,e]});return{...a,
value:BigInt(a.value),gasLimit:BigInt(a.gasLimit),gasUsed:q(a.gasUsed),seqno:q(a.seqno),index:a.index?
k(a.index):0}}async getMessageReceiptByHash(e,s=this.shardId){f(s);const a=r=>({...r,gasUsed:BigInt(
r.gasUsed),gasPrice:r.gasPrice?BigInt(r.gasPrice):0n,outputReceipts:r.outputReceipts?.map(i=>i===null?
null:a(i))??null}),n=await this.request({method:"eth_getInMessageReceipt",params:[s,u(typeof e=="str\
ing"?e:I(e))]});return n===null?null:a(n)}async sendRawMessage(e){return await this.request({method:"\
eth_sendRawTransaction",params:[typeof e=="string"?e:u(I(e))]})}async getGasPrice(e){const s=await this.
request({method:"eth_gasPrice",params:[e]});return q(s)}async estimateGasLimit(){return BigInt(1e6)}async chainId(){
const e=await this.request({method:"eth_chainId",params:[]});return k(e)}async getCurrencies(e,s){const a=await this.
request({method:"eth_getCurrencies",params:[e,s]}),n={};if(a)for(const[r,i]of Object.entries(a))n[r]=
q(i);return n}async call(e,s,a){let n;e.abi?n=w({abi:e.abi,functionName:e.functionName,args:e.args||
[]}):n=typeof e.data=="string"?e.data:u(I(e.data));const r=[{from:e.from||void 0,to:e.to,data:n,value:B(
e.value||0n),feeCredit:(e.feeCredit||5000000n).toString(10)},s];a&&r.push(a);const i=await this.request(
{method:"eth_call",params:r});if(e.abi){const l=qe({abi:e.abi,functionName:e.functionName,data:i.data});
return{...i,decodedData:l}}return i}}const vt=t=>u(B(Ae(t).slice(0,32)));const ne=(t,e=!1)=>{const s=U.
getPublicKey(C(t),e);return u($e(s))},re=(t,e)=>{f(e);const s=C(t),a=typeof s=="string"?Ce(s):s,n=x(
a),r=m(e,2),i=m(n,32);return B(new Uint8Array([...r,...i.slice(14)]))};class It{constructor(e){this.
publicKey=void 0,this.address=void 0;const{privateKey:s,mnemonic:a}=e;c(s||a,"Either privateKey or m\
nemonic must be provided.");const n=a?vt(a):u(s);ae(n),this.privateKey=n}async sign(e){const s=U.sign(
e,C(this.privateKey)),{r:a,s:n,recovery:r}=s;return E(m(a,32),m(n,32),m(r,1))}async getPublicKey(){if(this.
publicKey)return d(this.publicKey);const e=ne(this.privateKey,!0);return this.publicKey=e,d(this.publicKey)}async getAddress(e){
if(this.address)return d(this.address);const s=await this.getPublicKey();return this.address=re(I(s),
e),d(this.address)}}const xt=()=>B(U.utils.randomPrivateKey());let $t=class{constructor(){c(typeof window<
"u","MetaMaskSigner can be used in the browser only"),c(typeof window.ethereum<"u","No MetaMask prov\
ider found. Please install MetaMask browser extension before using MetaMaskSigner"),this.provider=window.
ethereum}async sign(e){return new Uint8Array(65)}async getAddress(){return new Uint8Array(20)}async getPublicKey(){
return new Uint8Array(33)}async connect(){await this.provider.request({method:"eth_requestAccounts"})}};
const ie=async(t,e,s,a)=>{const n=a?.interval||1e3,r=a?.waitTillMainShard||!0,i=[],l=[[e,s]];let p=0;
for(;p!==l.length;){const[b,y]=l[p],h=await t.getMessageReceiptByHash(y,b);if(!h){await new Promise(
o=>setTimeout(o,n));continue}if(h.outMessages!==null&&h.outputReceipts&&h.outputReceipts.filter(o=>o!==
null).length!==h.outMessages.length){await new Promise(o=>setTimeout(o,n));continue}if(r&&h.shardId!==
0&&!h.includedInMain){await new Promise(o=>setTimeout(o,n));continue}if(p++,i.push(h),h.outputReceipts)
for(const o of h.outputReceipts)o!==null&&l.push([o.shardId,o.messageHash])}return i};const Ct=t=>BigInt(
t*1e18);const Bt=t=>{const e=new Te(t,{headers:{"Client-Version":X}}),s=new Me([e]);return new Ne(s)};
let qt=class{constructor(e){this.rpcClient=Bt(e.endpoint),this.timeout=e.timeout!==void 0?e.timeout:
2e4}async request(e){return this.rpcClient.request(e,this.timeout)}connect(){}closeConnection(){this.
rpcClient.close()}};class At{constructor(e){this.timeout=e.timeout!==void 0?e.timeout:2e4,c(typeof window<
"u","MetaMaskTransport can be used in the browser only"),c(typeof window.ethereum<"u","No MetaMask p\
rovider found. Please install MetaMask browser extension before using MetaMaskSigner"),this.provider=
window.ethereum}async request(e){return this.provider.request(e)}connect(){this.provider.request({method:"\
eth_requestAccounts"})}closeConnection(){}}class Tt{}class oe extends N{constructor({shardId:e,...s}){
super(`Expected a valid shardId but got: ${e}`,{...s})}}class ce extends N{constructor({max:e,min:s,
value:a,...n}){super(`Number "${a}" is not in safe integer range ${e?`(${s} to ${e})`:`(above ${s})`}`,
{...n})}}const de=class T{constructor(e){this.client=e}async withdrawTo(e,s=1000000000000000000n,a){
const[n,r]=await Promise.all([a??this.client.getMessageCount(T.address,"latest"),this.client.chainId()]),
i=w({abi:G.abi,functionName:"withdrawTo",args:[e.toLowerCase(),s]}),l=new M({isDeploy:!1,to:d(T.address),
chainId:r,seqno:n,data:d(i),authData:new Uint8Array(0)}),p=l.encode();return await this.client.sendRawMessage(
g(p)),l.hash()}async withdrawToWithRetry(e,s=1000000000000000000n,a=5){let n=0;for(;n++<a;)try{const[
r,i]=await Promise.all([this.client.getMessageCount(T.address,"latest"),this.client.chainId()]),l=w(
{abi:G.abi,functionName:"withdrawTo",args:[e.toLowerCase(),s]}),p=new M({isDeploy:!1,to:d(T.address),
chainId:i,seqno:r,data:d(l),authData:new Uint8Array(0)}),b=p.encode();await this.client.sendRawMessage(
g(b));const y=g(p.hash()),h=await Promise.race([new Promise(o=>setTimeout(()=>o([]),1e4)),ie(this.client,
F(T.address),y)]);if(h.length===0||h.some(o=>!o.success))continue;return y}catch(r){if(await new Promise(
i=>setTimeout(i,1e3)),n>=a)throw r}throw new Error("Failed to withdraw to the given address")}};de.address=
"0x000100000000000000000000000000000FA00CE7";let Mt=de;const V=class P{static calculateWalletAddress({
pubKey:e,shardId:s,salt:a}){const{address:n}=S({abi:v.abi,bytecode:P.code,args:[g(e)],salt:a,shard:s});
return n}constructor({pubkey:e,shardId:s,address:a,client:n,salt:r,signer:i}){this.pubkey=dt(e),this.
client=n,this.signer=i,c(!(r&&a),"You should use salt and shard for calculating address or address i\
tself, not both to avoid issue."),this.address=a?A(a):P.calculateWalletAddress({pubKey:this.pubkey,shardId:s,
salt:r}),r&&(this.salt=Z(r)),this.shardId=F(B(this.address))}getAddressHex(){return g(this.address)}async selfDeploy(e=!0){
c(typeof this.salt<"u","Salt is required for external deployment. Please provide salt for walelt");const[
s,a]=await Promise.all([await this.client.getBalance(this.getAddressHex(),"latest"),await this.client.
getCode(this.getAddressHex(),"latest").catch(()=>Uint8Array.from([]))]);c(a.length===0,"Contract alr\
eady deployed"),c(s>0n,"Insufficient balance");const{data:n}=S({abi:v.abi,bytecode:P.code,args:[g(this.
pubkey)],salt:this.salt,shard:this.shardId}),{hash:r}=await this.requestToWallet({data:n,deploy:!0,seqno:0});
if(e)for(;!((await this.client.getCode(this.getAddressHex(),"latest")).length>0);)await new Promise(
i=>setTimeout(i,1e3));return r}async checkDeploymentStatus(){return(await this.client.getCode(this.getAddressHex(),
"latest")).length>0}async requestToWallet(e,s=!0){const[a,n]=await Promise.all([e.seqno??this.client.
getMessageCount(this.getAddressHex(),"latest"),e.chainId??this.client.chainId()]),r=await te({isDeploy:e.
deploy,to:this.address,chainId:n,seqno:a,data:e.data},this.signer);return s&&await this.client.sendRawMessage(
r.raw),r}async sendMessage({to:e,refundTo:s,bounceTo:a,data:n,abi:r,functionName:i,args:l,deploy:p,seqno:b,
feeCredit:y,value:h,tokens:o,chainId:he}){const ue=g(A(e)),ge=g(A(s??this.address)),pe=g(A(a??this.address)),
ye=ee({data:n,abi:r,functionName:i,args:l}),me=w({abi:v.abi,functionName:"asyncCall",args:[ue,ge,pe,
y,!!p,o??[],h??0n,ye]}),{hash:fe}=await this.requestToWallet({data:d(me),deploy:!1,seqno:b,chainId:he});
return g(fe)}async setCurrencyName(e){const s=w({abi:v.abi,functionName:"setCurrencyName",args:[e]}),
{hash:a}=await this.requestToWallet({data:d(s),deploy:!1});return g(a)}async mintCurrency(e){return await this.
changeCurrencyAmount(e,!0)}async burnCurrency(e){return await this.changeCurrencyAmount(e,!1)}async changeCurrencyAmount(e,s){
let a="burnCurrency";s&&(a="mintCurrency");const n=w({abi:v.abi,functionName:a,args:[e]}),{hash:r}=await this.
requestToWallet({data:d(n),deploy:!1});return g(r)}async sendRawInternalMessage(e){const{hash:s}=await this.
requestToWallet({data:e,deploy:!1});return g(s)}async deployContract({shardId:e,bytecode:s,abi:a,args:n,
salt:r,value:i,feeCredit:l,seqno:p,chainId:b}){let y;a&&n?y={shard:e,bytecode:s,abi:a,args:n,salt:r}:
(c(!(a||n),"ABI and args should be provided together or not provided at all."),y={shard:e,bytecode:s,
salt:r});const{data:h,address:o}=S(y);return{hash:await this.sendMessage({to:o,refundTo:this.getAddressHex(),
data:h,value:i??0n,deploy:!0,feeCredit:l,seqno:p,chainId:b}),address:g(o)}}async syncSendMessage({to:e,
data:s,abi:a,functionName:n,args:r,seqno:i,gas:l,value:p}){const b=g(A(e)),y=ee({data:s,abi:a,functionName:n,
args:r}),h=w({abi:v.abi,functionName:"syncCall",args:[b,l,p,y]}),{hash:o}=await this.requestToWallet(
{data:d(h),deploy:!1,seqno:i});return g(o)}async getBalance(){return this.client.getBalance(this.getAddressHex(),
"latest")}};V.code=d(u(v.evm.bytecode.object)),V.abi=v.abi;let Nt=V;export{O as BlockNotFoundError,M as ExternalMessageEnvelope,Mt as Faucet,qt as HttpTransport,Tt as ITransport,
ce as IntegerOutOfRangeError,lt as InternalMessageEnvelope,oe as InvalidShardIdError,It as LocalECDSAKeySigner,
$t as MetaMaskSigner,At as MetaMaskTransport,wt as PublicClient,K as SszMessageSchema,W as SszSignedMessageSchema,
Nt as WalletV1,u as addHexPrefix,mt as assertIsAddress,pt as assertIsBuffer,gt as assertIsHexString,
ft as assertIsValidBlock,yt as assertIsValidDeployData,ae as assertIsValidPrivateKey,f as assertIsValidShardId,
I as bytesToHex,it as bytesToString,Q as calculateAddress,et as concatHex,Ct as convertEthToWei,ht as externalDeploymentMessage,
te as externalMessageEncode,xt as generateRandomPrivateKey,re as getAddressFromPublicKey,ne as getPublicKey,
F as getShardIdFromAddress,q as hexToBigInt,d as hexToBytes,k as hexToNumber,J as isAddress,j as isHexString,
se as isValidBlock,x as poseidonHash,A as refineAddress,C as removeHexPrefix,B as toHex,ie as waitTillCompleted};
//# sourceMappingURL=niljs.esm.js.map
