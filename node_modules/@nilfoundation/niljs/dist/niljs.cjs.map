{"version":3,"file":"niljs.cjs","sources":["../src/version.ts","../src/errors/BaseError.ts","../src/utils/hex.ts","../src/encoding/fromHex.ts","../src/encoding/toHex.ts","../src/encoding/fromBytes.ts","../src/encoding/poseidon.ts","../src/encoding/ssz.ts","../src/utils/address.ts","../src/utils/refiners.ts","../src/encoding/deployPart.ts","../src/encoding/externalMessage.ts","../src/errors/block.ts","../src/clients/constants.ts","../src/utils/block.ts","../src/utils/assert.ts","../src/clients/BaseClient.ts","../src/clients/PublicClient.ts","../src/signers/mnemonic.ts","../src/signers/publicKey.ts","../src/signers/LocalECDSAKeySigner.ts","../src/signers/privateKey.ts","../src/signers/MetmaskSigner.ts","../src/utils/receipt.ts","../src/utils/eth.ts","../src/rpc/rpcClient.ts","../src/transport/HttpTransport.ts","../src/transport/MetaMaskTransport.ts","../src/transport/types/ITransport.ts","../src/errors/shardId.ts","../src/errors/encoding.ts","../src/contracts/Faucet/Faucet.ts","../src/contracts/WalletV1/WalletV1.ts"],"sourcesContent":["import pkgJson from \"../package.json\";\n\nconst version = pkgJson.version;\n\nexport { version };\n","import { version } from \"../version.js\";\n\n/**\n * The interface for the parameters of the BaseError constructor.\n */\ntype IBaseErrorParameters = {\n  /**\n   * The flag that indicates if this error is operational.\n   * This is useful to differentiate operational errors from programming errors.\n   * It is recommended to always set this property to true when creating a custom error class.\n   * @default true\n   */\n  isOperational?: boolean;\n  /**\n   * The error cause.\n   */\n  cause?: Error | BaseError;\n  /**\n   * The path to the documentation of this error.\n   */\n  docsPath?: string;\n};\n\n/**\n * The base class for custom errors.\n */\nclass BaseError extends Error {\n  /**\n   * The flag that indicates if this error is operational.\n   * This is useful to differentiate operational errors from programming errors.\n   * It is recommended to always set this property to true when creating a custom error class.\n   * @public\n   * @type {boolean}\n   */\n  public isOperational: boolean;\n  /**\n   * The error cause.\n   *\n   * @public\n   * @type {?(Error | BaseError)}\n   */\n  public cause?: Error | BaseError;\n  /**\n   * The path to the documentation of this error.\n   *\n   * @public\n   * @type {?string}\n   */\n  public docsPath?: string;\n  /**\n   * The version of the client.\n   */\n  public version?: string;\n\n  /**\n   * Creates an instance of BaseError.\n   *\n   * @constructor\n   * @param {?string} [message] The error message.\n   * @param {IBaseErrorParameters} [param0={}] The error params.\n   * @param {boolean} [param0.isOperational=true] The flag that determines whether the error is operational.\n   * @param {*} param0.cause The error cause.\n   * @param {string} param0.docsPath The path to the documentation of this error.\n   * @param {string} param0.version The version of the client.\n   */\n  constructor(\n    message?: string,\n    { isOperational = true, cause, docsPath }: IBaseErrorParameters = {},\n  ) {\n    super();\n    this.name = this.constructor.name;\n    this.isOperational = isOperational;\n    this.cause = cause;\n    this.docsPath = docsPath;\n    this.version = version;\n\n    this.message = `${message ?? \"An error occured\"}\n      Name: ${this.name}`;\n\n    if (docsPath) {\n      this.message = `${this.message}\n      Docs: see \\${this.docsPath}`;\n    }\n\n    if (version) {\n      this.message = `${this.message}\n      Version of the client: ${this.version}`;\n    }\n\n    // This line is needed to make the instanceof operator work correctly with custom errors in TypeScript\n    Object.setPrototypeOf(this, BaseError.prototype);\n  }\n}\n\nexport { BaseError, type IBaseErrorParameters };\n","import type { Hex } from \"../index.js\";\n\nconst HEX_REGEX = /^[0-9a-fA-F]+$/;\n\n/**\n * Checks if the value is a hex string. If the value is a hex string, returns true.\n * Otherwise, returns false.\n * @param value The value to check.\n */\nconst isHexString = (value: unknown): value is Hex => {\n  return (\n    typeof value === \"string\" &&\n    value.startsWith(\"0x\") &&\n    HEX_REGEX.test(removeHexPrefix(value) as string)\n  );\n};\n\n/**\n * Remove the hex prefix from the hex string.\n * @param hex The string whose hex prefix should be removed.\n * @returns The base-16 string.\n */\nconst removeHexPrefix = (str: Hex | string): string => {\n  return str.startsWith(\"0x\") ? str.slice(2) : str;\n};\n\n/**\n * Add the hex prefix to the hex string.\n * @param hex The string to which the prefix should be added.\n * @returns The string with the prefix.\n */\nconst addHexPrefix = (str: Hex | string): Hex => {\n  return `0x${removeHexPrefix(str)}`;\n};\n\n/**\n * Concatenates an array of hex strings. The hex strings are concatenated without the \"0x\" prefix.\n * The resulting hex string will have the \"0x\" prefix.\n * @param values - An array of hex strings.\n * @returns The concatenated hex string.\n */\nconst concatHex = (values: readonly Hex[]): Hex => {\n  return addHexPrefix(\n    (values as Hex[]).reduce((acc, x) => acc + x.replace(\"0x\", \"\"), \"\"),\n  );\n};\n\nexport { isHexString, removeHexPrefix, addHexPrefix, concatHex };\n","import { BaseError } from \"../errors/BaseError.js\";\nimport type { Hex } from \"../index.js\";\nimport { addHexPrefix, removeHexPrefix } from \"../utils/hex.js\";\n\n/**\n * Converts a character code to a base16 number.\n * @param charCode The character code to convert.\n * @returns The base16 representation of the input.\n */\nconst charCodeToBase16 = (charCode: number): number | undefined => {\n  if (charCode >= 48 && charCode <= 57) {\n    return charCode - 48;\n  }\n  if (charCode >= 65 && charCode <= 70) {\n    return charCode - 55;\n  }\n  if (charCode >= 97 && charCode <= 102) {\n    return charCode - 87;\n  }\n  return undefined;\n};\n\n/**\n * Converts a hex string to a number.\n * @param hex The hex string to convert.\n * @returns The number representation of the input.\n */\nconst hexToNumber = (hex: Hex): number => {\n  return Number.parseInt(removeHexPrefix(hex), 16);\n};\n\n/**\n * Converts a hex string to a bigint.\n * @param hex The hex string to convert.\n * @returns The bigint representation of the input.\n */\nconst hexToBigInt = (hex: Hex): bigint => {\n  return BigInt(addHexPrefix(hex));\n};\n\n/**\n * Converts a hex string to a byte array.\n *\n * @param {Hex} hex The hex string to convert.\n * @returns {Uint8Array} The byte array representation of the input.\n */\nconst hexToBytes = (hex: Hex): Uint8Array => {\n  let hexString = hex.slice(2);\n  if (hexString.length % 2) {\n    hexString = `0${hexString}`;\n  }\n\n  const length = hexString.length / 2;\n  const bytes = new Uint8Array(length);\n\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      );\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight;\n  }\n  return bytes;\n};\n\nexport { hexToNumber, hexToBigInt, hexToBytes };\n","import { type Hex, IntegerOutOfRangeError, addHexPrefix } from \"../index.js\";\n\n// biome-ignore lint/style/useNamingConvention: <explanation>\nconst hexes = Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, \"0\"),\n);\n\n/**\n * Converts a string to a hex string.\n * @param str The input string to convert.\n * @returns The hex string representation of the input.\n */\nconst stringToHex = (str: string): Hex => {\n  let hex = \"\";\n\n  for (let i = 0; i < str.length; i++) {\n    hex += str.charCodeAt(i).toString(16);\n  }\n\n  return addHexPrefix(hex);\n};\n\n/**\n * Converts bytes to a hex string.\n * @param bytes The bytes to convert.\n * @returns The hex string representation of the input.\n */\nconst bytesToHex = (bytes: Uint8Array): Hex => {\n  let hex = \"\";\n\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n\n  return addHexPrefix(hex);\n};\n\n/**\n * Converts an unsigned number to a hex string.\n * @param num The number to convert.\n * @returns The hex string representation of the input.\n */\nconst numberToHex = (num: number | bigint): Hex => {\n  const value = BigInt(num);\n  const maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  const minValue = 0;\n\n  if (\n    typeof num !== \"bigint\" &&\n    ((maxValue && value > maxValue) || value < minValue)\n  ) {\n    throw new IntegerOutOfRangeError({\n      max: maxValue,\n      min: minValue,\n      value,\n    });\n  }\n\n  return addHexPrefix(value.toString(16));\n};\n\n/**\n * Converts a string, number, bigint, boolean, or ByteArrayType to a hex string.\n * @param value The input to convert.\n * @returns The hex string representation of the input.\n */\nconst toHex = <T extends string | Uint8Array | boolean | bigint | number>(\n  value: T,\n): Hex => {\n  if (typeof value === \"string\") {\n    return stringToHex(value);\n  }\n\n  if (value instanceof Uint8Array) {\n    return bytesToHex(value);\n  }\n\n  if (typeof value === \"number\" || typeof value === \"bigint\") {\n    return numberToHex(value);\n  }\n\n  return addHexPrefix((value ? 1 : 0).toString(16));\n};\n\nexport { toHex };\n","import type { Hex } from \"../index.js\";\nimport { toHex } from \"./toHex.js\";\n\nconst decoder = new TextDecoder(\"utf8\");\n\n/**\n * Converts bytes to a string.\n * @param bytes The bytes to convert.\n * @returns The string representation of the input.\n */\nconst bytesToString = (bytes: Uint8Array): string => {\n  const str = decoder.decode(bytes);\n\n  return str;\n};\n\nconst bytesToHex = (bytes: Uint8Array): Hex => {\n  return toHex(bytes);\n};\n\nexport { bytesToString, bytesToHex };\n","import * as pkg from \"@iden3/js-crypto\";\nlet poseidon: typeof pkg.poseidon;\nif (\n  \"default\" in pkg &&\n  typeof pkg.default === \"object\" &&\n  pkg.default !== null &&\n  \"poseidon\" in pkg.default &&\n  typeof pkg.default.poseidon === \"function\"\n) {\n  poseidon = pkg.default.poseidon as typeof pkg.poseidon;\n} else {\n  poseidon = pkg.poseidon;\n}\n\n/**\n * Creates the Poseidon hash of the given bytes.\n * @param byes The bytes to hash.\n * @returns The Poseidon hash.\n */\nconst poseidonHash = (bytes: Uint8Array) => {\n  return poseidon.hashBytesX(bytes, 16);\n};\n\nexport { poseidonHash };\n","import {\n  hashObjectToUint8Array,\n  setHasher,\n  uint8ArrayToHashObject,\n} from \"@chainsafe/persistent-merkle-tree\";\nimport {\n  BooleanType,\n  ByteListType,\n  ByteVectorType,\n  ContainerType,\n  UintBigintType,\n  UintNumberType,\n} from \"@chainsafe/ssz\";\nimport { concatBytes } from \"@noble/curves/abstract/utils\";\nimport { poseidonHash } from \"./poseidon.js\";\n\nsetHasher({\n  digest64(a, b) {\n    const hash = poseidonHash(concatBytes(a, b));\n    const arr = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) {\n      // Shift the BigInt to the right by 8 * i bits, then take the 8 least significant bits\n      arr[31 - i] = Number((hash >> BigInt(i * 8)) & BigInt(0xff));\n    }\n    return arr;\n  },\n  digest64HashObjects(a, b) {\n    const hash = poseidonHash(\n      concatBytes(hashObjectToUint8Array(a), hashObjectToUint8Array(b)),\n    );\n    const arr = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) {\n      // Shift the BigInt to the right by 8 * i bits, then take the 8 least significant bits\n      arr[31 - i] = Number((hash >> BigInt(i * 8)) & BigInt(0xff));\n    }\n    return uint8ArrayToHashObject(arr);\n  },\n});\n\n/**\n * The basic types used in the library.\n *\n */\nconst basicTypes = {\n  Uint8: new UintNumberType(1),\n  Uint32: new UintNumberType(4),\n  Uint64: new UintNumberType(8),\n  UintBn256: new UintBigintType(32),\n  Bool: new BooleanType(),\n};\n\n/**\n * The const representing a byte vector with 20 elements.\n *\n */\nconst Bytes20 = new ByteVectorType(20);\n\n/**\n * The SSZ schema for a message object.\n */\nconst SszMessageSchema = new ContainerType({\n  deploy: basicTypes.Bool,\n  feeCredit: basicTypes.UintBn256,\n  to: Bytes20,\n  chainId: basicTypes.Uint64,\n  seqno: basicTypes.Uint64,\n  data: new ByteListType(24576),\n});\n\n/**\n * SSZ schema for a signed message object. Includes auth data in addition to all other message fields.\n */\nconst SszSignedMessageSchema = new ContainerType({\n  ...SszMessageSchema.fields,\n  authData: new ByteListType(256),\n});\n\nexport { SszMessageSchema, SszSignedMessageSchema };\n","import { numberToBytesBE } from \"@noble/curves/abstract/utils\";\nimport { poseidonHash } from \"../encoding/poseidon.js\";\nimport { hexToBytes } from \"../index.js\";\nimport type { IAddress } from \"../signers/types/IAddress.js\";\n\n/**\n * The regular expression for matching addresses.\n *\n */\nconst ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/;\n\n/**\n * Checks if the value is an address. If the value is an address, returns true.\n * Otherwise, returns false.\n * @param value The value to check.\n */\nconst isAddress = (value: string): value is IAddress => {\n  return typeof value === \"string\" && ADDRESS_REGEX.test(value);\n};\n\n/**\n * Returns the ID of the shard containing the provided address.\n * @param address The address.\n */\nconst getShardIdFromAddress = (address: string): number => {\n  if (typeof address === \"string\") {\n    return Number.parseInt(address.slice(2, 6), 16);\n  }\n\n  return (address[0] << 8) | address[1];\n};\n\n/**\n * Calculates an address.\n *\n * @param {number} shardId The ID of the shard containing the address.\n * @param {Uint8Array} code The bytecode to be deployed at the address.\n * @param {Uint8Array} salt Arbitrary data for address generation.\n * @returns {Uint8Array} The address.\n */\nconst calculateAddress = (\n  shardId: number,\n  code: Uint8Array,\n  salt: Uint8Array,\n): Uint8Array => {\n  if (!Number.isInteger(shardId)) {\n    throw new Error(\"Shard ID must be an integer\");\n  }\n  if (salt.length !== 32) {\n    throw new Error(\"Salt must be 32 bytes\");\n  }\n  if (code.length === 0) {\n    throw new Error(\"Code must not be empty\");\n  }\n  if (shardId < 0 || shardId > 0xffff) {\n    throw new Error(\"Invalid shard ID\");\n  }\n  const bytes = new Uint8Array(code.length + 32);\n  bytes.set(code);\n  bytes.set(salt, code.length);\n  const hash = poseidonHash(bytes);\n  const shardPart = numberToBytesBE(shardId, 2);\n  const hashPart = numberToBytesBE(hash, 32);\n\n  return new Uint8Array([...shardPart, ...hashPart.slice(14)]);\n};\n\n/**\n * Refines the address.\n *\n * @param {(Uint8Array | `0x`)} address The address to refine.\n * @returns {Uint8Array} The refined address.\n */\nconst refineAddress = (address: Uint8Array | `0x${string}`): Uint8Array => {\n  if (typeof address === \"string\") {\n    const bytes = hexToBytes(address);\n    if (bytes.length !== 20) {\n      throw new Error(\"Invalid address length\");\n    }\n    return bytes;\n  }\n  if (address.length !== 20) {\n    throw new Error(\"Invalid address length\");\n  }\n  return address;\n};\n\nexport { isAddress, getShardIdFromAddress, calculateAddress, refineAddress };\n","import invariant from \"tiny-invariant\";\nimport { addHexPrefix } from \"./hex.js\";\nimport type {Abi} from \"abitype\";\nimport {encodeFunctionData} from \"viem\";\nimport {hexToBytes, bytesToHex} from \"../encoding/index.js\";\nimport type {Hex} from \"../types/index.js\";\n\nconst refineSalt = (salt: Uint8Array | bigint): Uint8Array => {\n  if (typeof salt === \"bigint\") {\n    return hexToBytes(addHexPrefix(salt.toString(16).padStart(64, \"0\"))).slice(\n      0,\n      32,\n    );\n  }\n\n  invariant(salt.length === 32, \"Salt must be 32 bytes\");\n\n  return salt;\n};\n\nconst refineCompressedPublicKey = (\n  pubkey: Uint8Array | `0x${string}`,\n): Uint8Array => {\n  const res = typeof pubkey === \"string\" ? hexToBytes(pubkey) : pubkey;\n  invariant(pubkey.length === 33, \"Invalid pubkey length\");\n\n  return res;\n};\n\nconst refineFunctionHexData = ({\n  data,\n  abi,\n  functionName,\n  args,\n}: {\n  data?: Uint8Array | Hex;\n  abi?: Abi;\n  functionName?: string;\n  args?: unknown[];\n}): Hex => {\n  if (!data && !abi) {\n    return \"0x\";\n  }\n  invariant(!(data && (abi)), \"ABI and data cannot be provided together\");\n  if (data) {\n    return typeof data === \"string\" ? data : bytesToHex(data);\n  }\n  invariant(abi && functionName, \"ABI and functionName is required\");\n  return encodeFunctionData({\n    abi,\n    functionName,\n    args: args || [],\n  });\n}\n\nexport { refineSalt, refineCompressedPublicKey, refineFunctionHexData };\n","import { encodeDeployData } from \"viem\";\nimport type { IDeployData } from \"../types/IDeployData.js\";\nimport { calculateAddress } from \"../utils/address.js\";\nimport { refineSalt } from \"../utils/refiners.js\";\nimport { bytesToHex } from \"./fromBytes.js\";\nimport { hexToBytes } from \"./fromHex.js\";\n\n/**\n * Refines the provided salt and generates the full bytecode for deployment. Returns the bytecode and the deployment address.\n *\n * @param {IDeployData} data The deployment data.\n * @returns {{ data: Uint8Array; address: Uint8Array }} The object containing the final bytecode and the deployment address.\n */\nexport const prepareDeployPart = (\n  data: IDeployData,\n): { data: Uint8Array; address: Uint8Array } => {\n  const byteSalt = refineSalt(data.salt);\n  let constructorData: Uint8Array;\n  if (data.abi) {\n    constructorData = hexToBytes(\n      encodeDeployData({\n        abi: data.abi,\n        bytecode:\n          typeof data.bytecode === \"string\"\n            ? data.bytecode\n            : bytesToHex(data.bytecode),\n        args: data.args || [],\n      }),\n    );\n  } else {\n    constructorData =\n      typeof data.bytecode === \"string\"\n        ? hexToBytes(data.bytecode)\n        : data.bytecode;\n  }\n  const bytecode = new Uint8Array([...constructorData, ...byteSalt]);\n  const address = calculateAddress(data.shard, constructorData, byteSalt);\n  return { data: bytecode, address: address };\n};\n","import { numberToBytesBE } from \"@noble/curves/abstract/utils\";\nimport type { PublicClient } from \"../clients/PublicClient.js\";\nimport type { ISigner } from \"../signers/index.js\";\nimport type { ExternalMessage } from \"../types/ExternalMessage.js\";\nimport type { IDeployData } from \"../types/IDeployData.js\";\nimport { prepareDeployPart } from \"./deployPart.js\";\nimport { bytesToHex } from \"./fromBytes.js\";\nimport { poseidonHash } from \"./poseidon.js\";\nimport { SszMessageSchema, SszSignedMessageSchema } from \"./ssz.js\";\n\n/**\n * The envelope for an external message (a message sent by a user, a dApp, etc.)\n *\n * @class ExternalMessageEnvelope\n * @typedef {ExternalMessageEnvelope}\n */\nexport class ExternalMessageEnvelope {\n  /**\n   * The flag that determines whether the external message is a deployment message.\n   *\n   * @type {boolean}\n   */\n  isDeploy: boolean;\n  /**\n   * The destination address of the message.\n   *\n   * @type {Uint8Array}\n   */\n  to: Uint8Array;\n  /**\n   * The chain ID.\n   *\n   * @type {number}\n   */\n  chainId: number;\n  /**\n   * The message sequence number.\n   *\n   * @type {number}\n   */\n  seqno: number;\n  /**\n   * The message data.\n   *\n   * @type {Uint8Array}\n   */\n  data: Uint8Array;\n  /**\n   * The auth data attached to the message.\n   *\n   * @type {Uint8Array}\n   */\n  authData: Uint8Array;\n  /**\n   * Creates an instance of ExternalMessageEnvelope.\n   *\n   * @constructor\n   * @param {ExternalMessage} param0 The object representing the external message.\n   * @param {ExternalMessage} param0.isDeploy The flag that determines whether the external message is a deployment message.\n   * @param {ExternalMessage} param0.to The destination address of the message.\n   * @param {ExternalMessage} param0.chainId The chain ID.\n   * @param {ExternalMessage} param0.seqno The message sequence number.\n   * @param {ExternalMessage} param0.data The message number.\n   * @param {ExternalMessage} param0.authData The auth data attached to the message.\n   */\n  constructor({\n    isDeploy,\n    to,\n    chainId,\n    seqno,\n    data,\n    authData,\n  }: ExternalMessage) {\n    this.isDeploy = isDeploy;\n    this.to = to;\n    this.chainId = chainId;\n    this.seqno = seqno;\n    this.data = data;\n    this.authData = authData;\n  }\n  /**\n   * Encodes the external message into a Uint8Array.\n   *\n   * @public\n   * @returns {Uint8Array} The encoded external message.\n   */\n  public encode(): Uint8Array {\n    return SszSignedMessageSchema.serialize({\n      feeCredit: 50000000n,\n      seqno: this.seqno,\n      chainId: this.chainId,\n      to: this.to,\n      data: this.data,\n      deploy: this.isDeploy,\n      authData: this.authData,\n    });\n  }\n  /**\n   * Provides the hash tree root of the external message.\n   *\n   * @public\n   * @returns {Uint8Array} The hash tree root of the external message.\n   */\n  public hash(): Uint8Array {\n    const raw = this.encode();\n    return numberToBytesBE(poseidonHash(raw), 32);\n  }\n  /**\n   * Provides the signing hash of the external message.\n   *\n   * @public\n   * @returns {Uint8Array} The signing hash of the external message.\n   */\n  public signingHash(): Uint8Array {\n    // print all the fields\n    const raw = SszMessageSchema.serialize({\n      feeCredit: 50000000n,\n      seqno: this.seqno,\n      chainId: this.chainId,\n      to: this.to,\n      data: this.data,\n      deploy: this.isDeploy,\n    });\n    return numberToBytesBE(poseidonHash(raw), 32);\n  }\n  /**\n   * Encodes the external message with its signature.\n   *\n   * @public\n   * @async\n   * @param {ISigner} signer The message signer.\n   * @returns {Promise<{\n   *     raw: Uint8Array;\n   *     hash: Uint8Array;\n   *   }>} The object containing the encoded message and its hash.\n   */\n  public async encodeWithSignature(signer: ISigner): Promise<{\n    raw: Uint8Array;\n    hash: Uint8Array;\n  }> {\n    const signature = await this.sign(signer);\n    const raw = SszSignedMessageSchema.serialize({\n      feeCredit: 50000000n,\n      seqno: this.seqno,\n      chainId: this.chainId,\n      to: this.to,\n      data: this.data,\n      deploy: this.isDeploy,\n      authData: signature,\n    });\n    const hash = numberToBytesBE(poseidonHash(raw), 32);\n    return { raw, hash };\n  }\n  /**\n   * Signs the external message.\n   *\n   * @public\n   * @async\n   * @param {ISigner} signer The message signer.\n   * @returns {Promise<Uint8Array>} The message signature.\n   */\n  public async sign(signer: ISigner): Promise<Uint8Array> {\n    return signer.sign(this.signingHash());\n  }\n  /**\n   * Updates the authentication data in the external message and returns the result.\n   *\n   * @public\n   * @async\n   * @param {ISigner} signer The auth data signer.\n   * @returns {Promise<Uint8Array>} The signed auth data.\n   */\n  public async updateAuthdata(signer: ISigner): Promise<Uint8Array> {\n    this.authData = await this.sign(signer);\n    return this.authData;\n  }\n  /**\n   * Returns the hex address of the given bytes.\n   *\n   * @public\n   * @returns {`0x${string}`} The hex address.\n   */\n  public hexAddress(): `0x${string}` {\n    return bytesToHex(this.to);\n  }\n  /**\n   * Sends the external message.\n   *\n   * @public\n   * @param {PublicClient} client The client sending the message.\n   * @returns {*} The hash of the external message.\n   */\n  public send(client: PublicClient) {\n    return client.sendRawMessage(this.encode());\n  }\n}\n\n/**\n * The envelope for an internal message (a message sent by a smart contract to another smart contract).\n *\n * @class InternalMessageEnvelope\n * @typedef {InternalMessageEnvelope}\n */\nexport class InternalMessageEnvelope {}\n\n/**\n * Creates a new external deployment message.\n *\n * @param {IDeployData} data The message data.\n * @param {number} chainId The chain ID.\n * @returns {ExternalMessageEnvelope} The envelope of the external deployment message.\n * @example\n * import {\n     Faucet,\n     LocalECDSAKeySigner,\n     HttpTransport,\n     PublicClient\n     WalletV1,\n     externalDeploymentMessage,\n     generateRandomPrivateKey,\n   } from '@nilfoundation/niljs';\n * const signer = new LocalECDSAKeySigner({\n     privateKey: generateRandomPrivateKey(),\n   });\n\n   const pubkey = await signer.getPublicKey();\n * const chainId = await client.chainId();\n * const deploymentMessage = externalDeploymentMessage(\n     {\n       salt: 100n,\n       shard: 1,\n       bytecode: WalletV1.code,\n       abi: WalletV1.abi,\n       args: [bytesToHex(pubkey)],\n     },\n     chainId,\n   );\n */\nexport const externalDeploymentMessage = (\n  data: IDeployData,\n  chainId: number,\n): ExternalMessageEnvelope => {\n  const { data: deployData, address } = prepareDeployPart(data);\n  return new ExternalMessageEnvelope({\n    isDeploy: true,\n    to: address,\n    chainId,\n    seqno: 0,\n    data: deployData,\n    authData: new Uint8Array(0),\n  });\n};\n\n/**\n * Encodes the given external message.\n *\n * @async\n * @param {Omit<ExternalMessage, \"authData\">} params The external message to be encoded without its auth data.\n * @param {ISigner} signer The message signer.\n * @returns {Promise<{ raw: Uint8Array; hash: Uint8Array }>} The message bytecode and the message hash.\n */\nexport const externalMessageEncode = async (\n  params: Omit<ExternalMessage, \"authData\">,\n  signer: ISigner,\n): Promise<{ raw: Uint8Array; hash: Uint8Array }> => {\n  const message = new ExternalMessageEnvelope({\n    ...params,\n    authData: new Uint8Array(0),\n  });\n  const res = await message.encodeWithSignature(signer);\n  return res;\n};\n","import type { Hex } from \"../index.js\";\nimport { BaseError, type IBaseErrorParameters } from \"./BaseError.js\";\n\n/**\n * The interface for the parameters of the {@link BlockNotFoundError} constructor.\n */\ntype BlockNotFoundErrorParameters = {\n  blockNumberOrHash: number | Hex;\n} & IBaseErrorParameters;\n\n/**\n * The error class for 'block not found' errors.\n * This error is thrown when the requested block is not found.\n */\nclass BlockNotFoundError extends BaseError {\n  /**\n   * Creates an instance of BlockNotFoundError.\n   *\n   * @constructor\n   * @param {BlockNotFoundErrorParameters} param0 The error params.\n   * @param {*} param0.blockNumberOrHash The block number or hash.\n   * @param {*} param0....rest The remaining error params, see {@link IBaseErrorParameters}.\n   */\n  constructor({ blockNumberOrHash, ...rest }: BlockNotFoundErrorParameters) {\n    super(`Block not found: ${blockNumberOrHash}`, { ...rest });\n  }\n}\n\nexport { BlockNotFoundError };\n","const emptyAddress = \"0x0000000000000000000000000000000000000000\";\nconst masterShardId = 0;\n\nexport { emptyAddress, masterShardId };\n","import type { Block } from \"../index.js\";\n\n/**\n * Checks if the provided block is valid.\n * @param block The block to check.\n * @returns True if the block is valid, false otherwise.\n */\nconst isValidBlock = (block: Block): block is Block => {\n  return true;\n};\n\nexport { isValidBlock };\n","import invariant from \"tiny-invariant\";\nimport { masterShardId } from \"../clients/constants.js\";\nimport type { IDeployData } from \"../clients/types/IDeployData.js\";\nimport { type Hex, InvalidShardIdError } from \"../index.js\";\nimport type { IPrivateKey } from \"../signers/index.js\";\nimport type { Block } from \"../types/Block.js\";\nimport { isAddress } from \"./address.js\";\nimport { isValidBlock } from \"./block.js\";\nimport { isHexString } from \"./hex.js\";\n\n/**\n * Checks if the value is a string.\n * @throws Will throw an error if the value is not a hex string.\n * @param value - The value to check.\n * @param message - The message to throw if the value is not a hex string.\n */\nconst assertIsHexString = (value: Hex, message?: string): void => {\n  invariant(\n    isHexString(value),\n    message ?? `Expected a hex string but got ${value}`,\n  );\n};\n\n/**\n * Checks if the value is a buffer.\n * @throws Will throw an error if value is not a buffer.\n * @param value - The value to check.\n * @param message - The message to throw if the value is not a buffer.\n */\nconst assertIsBuffer = (value: Uint8Array, message?: string): void => {\n  invariant(\n    value instanceof Uint8Array,\n    message ?? `Expected a buffer but got ${value}`,\n  );\n};\n\n/**\n * Checks if provided private key is valid. If the value is a hex string with length 32 nothing is returned.\n * @throws Will throw an error if provided private key is invalid.\n * @param privateKey - The private key to check.\n * @param message - The message to throw if the private key is invalid.\n */\nconst assertIsValidPrivateKey = (\n  privateKey: IPrivateKey,\n  message?: string,\n): void => {\n  invariant(\n    isHexString(privateKey) && privateKey.length === 32 * 2 + 2,\n    message ?? `Expected a valid private key, but got ${privateKey}`,\n  );\n};\n\n/**\n * Checks if the data to deploy contract is valid. If the data is valid, it returns nothing.\n * @throws Will throw an error if the value is not a valid data to deploy contract.\n * @param deployData - The data to validate.\n * @param message - The message to throw if the data is invalid.\n */\nconst assertIsValidDeployData = (\n  deployContractData: IDeployData,\n  message?: string,\n) => {\n  const { seqno, pubkey, shardId } = deployContractData;\n\n  if (seqno !== undefined) {\n    invariant(\n      seqno >= 0,\n      message ?? `Expected a valid 'seqno' but got ${seqno}`,\n    );\n  }\n\n  if (pubkey !== undefined) {\n    invariant(\n      typeof pubkey === \"string\",\n      message ?? `Expected a valid 'pubkey' but got ${pubkey}`,\n    );\n  }\n\n  assertIsValidShardId(shardId);\n};\n\n/**\n * Checks if the address is valid. If the address is valid, it returns nothing.\n * @param address - The address to check.\n * @param message - The message to throw if the address is invalid.\n */\nconst assertIsAddress = (address: string, message?: string): void => {\n  invariant(\n    isAddress(address),\n    message ?? `Expected a valid address but got ${address}`,\n  );\n};\n\n/**\n * Checks if the block is valid. If the block is valid, it returns nothing.\n * @param block - The block to check.\n * @param message - The message to throw if the block is invalid.\n */\nconst assertIsValidBlock = (block: Block, message?: string): void => {\n  invariant(\n    isValidBlock(block),\n    message ?? `Expected a valid block but got ${block}`,\n  );\n};\n\n/**\n * Checks if the shard id is valid. If the shard id is valid, it returns nothing.\n * @param shardId - The shard id to check.\n */\nconst assertIsValidShardId = (shardId?: number): void => {\n  const isValid =\n    typeof shardId === \"number\" &&\n    Number.isInteger(shardId) &&\n    shardId >= 0 &&\n    shardId < 2 ** 16 &&\n    shardId !== masterShardId;\n\n  if (!isValid) {\n    throw new InvalidShardIdError({ shardId });\n  }\n};\n\nexport {\n  assertIsBuffer,\n  assertIsHexString,\n  assertIsValidPrivateKey,\n  assertIsAddress,\n  assertIsValidBlock,\n  assertIsValidShardId,\n  assertIsValidDeployData,\n};\n","import type { RequestArguments } from \"@open-rpc/client-js/build/ClientInterface.js\";\nimport type { ITransport } from \"../transport/index.js\";\nimport { assertIsValidShardId } from \"../utils/assert.js\";\nimport type { IClientBaseConfig } from \"./types/ClientConfigs.js\";\n\n/**\n * BaseClient is the base class for any client tasked with interacting with =nil;\n * @class BaseClient\n * @typedef {BaseClient}\n */\nclass BaseClient {\n\t/**\n\t * The ITransport to be used in the client. See {@link ITransport}.\n\t *\n\t * @protected\n\t * @type {ITransport}\n\t */\n\tprotected transport: ITransport;\n\t/**\n\t * The ID of the shard with which the client needs to interact.\n\t * The shard with this ID will be used in every call made by the client.\n\t * @protected\n\t * @type {number | undefined}\n\t */\n\tprotected shardId?: number;\n\n\t/**\n\t * Creates an instance of BaseClient.\n\t * @constructor\n\t * @param {IClientBaseConfig} config The config to be used in the client. It contains the transport and the shard ID. See {@link IClientBaseConfig}.\n\t */\n\tconstructor(config: IClientBaseConfig) {\n\t\tthis.transport = config.transport;\n\t\tthis.shardId = config.shardId;\n\t}\n\n\t/**\n\t * Sends a request.\n\t * @param requestObject The request object. It contains the request method and parameters.\n\t * @returns The response.\n\t */\n\tprotected async request<T>(requestObject: RequestArguments): Promise<T> {\n\t\treturn this.transport.request(requestObject);\n\t}\n\n\t/**\n\t * Returns the shard ID.\n\t * @returns The shard ID.\n\t */\n\tpublic getShardId() {\n\t\treturn this.shardId;\n\t}\n\n\t/**\n\t * Sets the shard ID.\n\t * @param shardId The shard ID.\n\t * @throws Will throw an error if the provided shard ID is invalid.\n\t * @example\n\t * client.setShardId(1);\n\t */\n\tpublic setShardId(shardId: number): void {\n\t\tassertIsValidShardId(shardId);\n\n\t\tthis.shardId = shardId;\n\t}\n}\n\nexport { BaseClient };\n","import {\n  bytesToHex,\n  hexToBigInt,\n  hexToBytes,\n  hexToNumber,\n  toHex,\n} from \"../encoding/index.js\";\nimport { BlockNotFoundError } from \"../errors/block.js\";\nimport { type Hex, assertIsValidShardId } from \"../index.js\";\nimport type { IAddress } from \"../signers/types/IAddress.js\";\nimport type { Block, BlockTag } from \"../types/Block.js\";\nimport type { CallArgs, CallRes, ContractOverride } from \"../types/CallArgs.js\";\nimport type { IReceipt, ProcessedReceipt } from \"../types/IReceipt.js\";\nimport type { ProcessedMessage } from \"../types/ProcessedMessage.js\";\nimport type { RPCMessage } from \"../types/RPCMessage.js\";\nimport { addHexPrefix } from \"../utils/hex.js\";\nimport { BaseClient } from \"./BaseClient.js\";\nimport type { IPublicClientConfig } from \"./types/ClientConfigs.js\";\nimport type { Address } from \"abitype\";\nimport { decodeFunctionResult, encodeFunctionData } from \"viem\";\n\n/**\n * PublicClient is a class that allows for interacting with the network via the JSON-RPC API.\n * It provides an abstraction of the connection to =nil;.\n * PublicClient enables using API requests that do not require signing data (or otherwise using one's private key).\n * @example\n * import { PublicClient } from '@nilfoundation/niljs';\n *\n * const client = new PublicClient({\n *   transport: new HttpTransport({\n *     endpoint: RPC_ENDPOINT,\n *   }),\n *   shardId: 1,\n * });\n */\nclass PublicClient extends BaseClient {\n  /**\n   * Creates an instance of PublicClient.\n   *\n   * @constructor\n   * @param {IPublicClientConfig} config The config to be used in the client. See {@link IPublicClientConfig}.\n   */\n  // biome-ignore lint/complexity/noUselessConstructor: may be useful in the future\n  constructor(config: IPublicClientConfig) {\n    super(config);\n  }\n\n  /**\n   * Returns the block with the given hash.\n   * @param hash The hash of the block whose information is requested.\n   * @param fullTx The flag that determines whether full transaction information is returned in the output.\n   * @param shardId The ID of the shard where the block was generated.\n   * @returns Information about the block with the given hash.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *   transport: new HttpTransport({\n   *     endpoint: RPC_ENDPOINT,\n   *   }),\n   *   shardId: 1,\n   * });\n   *\n   * const block = await client.getBlockByHash(HASH);\n   */\n  public async getBlockByHash(\n    hash: Hex,\n    fullTx = false,\n    shardId = this.shardId,\n  ) {\n    assertIsValidShardId(shardId);\n\n    try {\n      return await this.request<Block<typeof fullTx>>({\n        method: \"eth_getBlockByHash\",\n        params: [shardId, hash, fullTx],\n      });\n    } catch (error) {\n      throw new BlockNotFoundError({\n        blockNumberOrHash: hash,\n        cause: error,\n      });\n    }\n  }\n\n  /**\n   * Returns the block with the given number.\n   * @param blockNumber The number of the block whose information is requested.\n   * @param fullTx The flag that determines whether full transaction information is returned in the output.\n   * @param shardId The ID of the shard where the block was generated.\n   * @returns Returns information about a block with the given number.\n   * @example\n   import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *  endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const block = await client.getBlockByNumber(1);\n   */\n  public async getBlockByNumber(\n    blockNumber: Hex,\n    fullTx = false,\n    shardId = this.shardId,\n  ) {\n    assertIsValidShardId(shardId);\n\n    try {\n      return await this.request<Block<typeof fullTx>>({\n        method: \"eth_getBlockByNumber\",\n        params: [shardId, blockNumber, fullTx],\n      });\n    } catch (error) {\n      throw new BlockNotFoundError({\n        blockNumberOrHash: blockNumber,\n        cause: error,\n      });\n    }\n  }\n\n  /**\n   * Returns the total number of messages recorded in the block with the given number.\n   * @param number The number of the block whose information is requested.\n   * @returns The number of messages contained within the block.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *  endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const count = await client.getBlockMessageCountByNumber(1);\n   *\n   */\n  public async getBlockMessageCountByNumber(\n    blockNumber: string,\n    shardId = this.shardId,\n  ) {\n    assertIsValidShardId(shardId);\n\n    const res = await this.request<number>({\n      method: \"eth_getBlockTransactionCountByNumber\",\n      params: [shardId, blockNumber],\n    });\n\n    return res;\n  }\n\n  /**\n   * Returns the total number of messages recorded in the block with the given hash.\n   * @param hash The hash of the block whose information is requested.\n   * @param shardId The ID of the shard where the block was generated.\n   * @returns The number of messages contained within the block.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *  endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const count = await client.getBlockMessageCountByHash(HASH);\n   */\n  public async getBlockMessageCountByHash(hash: Hex, shardId = this.shardId) {\n    assertIsValidShardId(shardId);\n\n    const res = await this.request<number>({\n      method: \"eth_getBlockTransactionCountByHash\",\n      params: [shardId, hash],\n    });\n\n    return res;\n  }\n\n  /**\n   * Returns the bytecode of the contract with the given address and at the given block.\n   * @param address The address of the account or contract.\n   * @param blockNumberOrHash The number/hash of the block.\n   * @param shardId The ID of the shard where the block was generated.\n   * @returns The bytecode of the contract.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *  endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const code = await client.getCode(ADDRESS, 'latest');\n   */\n  public async getCode(address: IAddress, blockNumberOrHash?: Hex | BlockTag) {\n    const res = await this.request<`0x${string}`>({\n      method: \"eth_getCode\",\n      params: [address, blockNumberOrHash ?? \"latest\"],\n    });\n\n    return hexToBytes(res);\n  }\n\n  /**\n   * Returns the transaction count of the account with the given address and at the given block.\n   * @param address The address of the account or contract.\n   * @param blockNumberOrHash The number/hash of the block.\n   * @returns The number of transactions contained within the block.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *  endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const count = await client.getMessageCount(ADDRESS, 'latest');\n   *\n   */\n  public async getMessageCount(\n    address: IAddress,\n    blockNumberOrHash?: Hex | BlockTag,\n  ) {\n    const res = await this.request<Hex>({\n      method: \"eth_getTransactionCount\",\n      params: [address, blockNumberOrHash ?? \"latest\"],\n    });\n\n    return hexToNumber(res);\n  }\n\n  /**\n   * Returns the balance of the given address and at the given block.\n   * @param address The address of the account or contract.\n   * @param blockNumberOrHash The number/hash of the block.\n   * @returns The balance of the address.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *  endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const balance = await client.getBalance(ADDRESS, 'latest');\n   */\n  public async getBalance(\n    address: IAddress,\n    blockNumberOrHash?: Hex | BlockTag,\n  ) {\n    const res = await this.request<`0x${string}`>({\n      method: \"eth_getBalance\",\n      params: [addHexPrefix(address), blockNumberOrHash ?? \"latest\"],\n    });\n\n    return hexToBigInt(res);\n  }\n\n  /**\n   * Returns the structure of the internal message with the given hash.\n   * @param hash The hash of the message.\n   * @param shardId The ID of the shard where the message was recorded.\n   * @returns The message whose information is requested.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *  endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const message = await client.getMessageByHash(HASH);\n   */\n  public async getMessageByHash(\n    hash: Hex,\n    shardId = this.shardId,\n  ): Promise<ProcessedMessage> {\n    assertIsValidShardId(shardId);\n\n    const res = await this.request<RPCMessage>({\n      method: \"eth_getInMessageByHash\",\n      params: [shardId, hash],\n    });\n\n    return {\n      ...res,\n      value: BigInt(res.value),\n      gasLimit: BigInt(res.gasLimit),\n      gasUsed: hexToBigInt(res.gasUsed),\n      seqno: hexToBigInt(res.seqno),\n      index: res.index ? hexToNumber(res.index) : 0,\n    };\n  }\n\n  /**\n   * Returns the receipt for the message with the given hash.\n   * @param hash The hash of the message.\n   * @param shardId The ID of the shard where the message was recorded.\n   * @returns The receipt whose structure is requested.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   * endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const receipt = await client.getMessageReceiptByHash(1, HASH);\n   */\n  public async getMessageReceiptByHash(\n    hash: Hex,\n    shardId = this.shardId,\n  ): Promise<ProcessedReceipt | null> {\n    assertIsValidShardId(shardId);\n\n    const mapReceipt = (receipt: IReceipt): ProcessedReceipt => {\n      return {\n        ...receipt,\n        gasUsed: BigInt(receipt.gasUsed),\n        gasPrice: receipt.gasPrice ? BigInt(receipt.gasPrice) : 0n,\n        outputReceipts:\n          receipt.outputReceipts?.map((x) => {\n            if (x === null) {\n              return null;\n            }\n            return mapReceipt(x);\n          }) ?? null,\n      };\n    };\n\n    const res = await this.request<IReceipt | null>({\n      method: \"eth_getInMessageReceipt\",\n      params: [\n        shardId,\n        typeof hash === \"string\"\n          ? addHexPrefix(hash)\n          : addHexPrefix(bytesToHex(hash)),\n      ],\n    });\n\n    if (res === null) {\n      return null;\n    }\n\n    return mapReceipt(res);\n  }\n\n  /**\n   * Creates a new message or creates a contract for a previously signed message.\n   * @param message The encoded bytecode of the message.\n   * @returns The hash of the message.\n   * @example\n   * import { PublicClient } from '@nilfoundation/niljs';\n   *\n   * const client = new PublicClient({\n   *  endpoint: RPC_ENDPOINT\n   * })\n   *\n   * const message = Uint8Array.from(ARRAY);\n   */\n  public async sendRawMessage(message: `0x${string}` | Uint8Array) {\n    const res = await this.request<Hex>({\n      method: \"eth_sendRawTransaction\",\n      params: [\n        typeof message === \"string\"\n          ? message\n          : addHexPrefix(bytesToHex(message)),\n      ],\n    });\n\n    return res;\n  }\n\n  /**\n   * Returns the gas price in wei.\n   * @returns The gas price.\n   */\n  public async getGasPrice(shardId: number): Promise<bigint> {\n    const price = await this.request<`0x${string}`>({\n      method: \"eth_gasPrice\",\n      params: [shardId],\n    });\n\n    return hexToBigInt(price);\n  }\n\n  /**\n   * Returns the gas limit.\n   * @returns The gas limit.\n   */\n  public async estimateGasLimit(): Promise<bigint> {\n    const stubGasLimit = BigInt(1000000);\n\n    return stubGasLimit;\n  }\n\n  /**\n   * Returns the chain ID.\n   * @returns The chain ID.\n   */\n  public async chainId(): Promise<number> {\n    const res = await this.request<Hex>({\n      method: \"eth_chainId\",\n      params: [],\n    });\n\n    return hexToNumber(res);\n  }\n\n  /**\n   * Returns all tokens at the given address.\n   * @param address The address whose information is requested.\n   * @param blockNumberOrHash The number/hash of the block.\n   * @returns The list of tokens.\n   */\n  public async getCurrencies(\n    address: IAddress,\n    blockNumberOrHash: Hex | BlockTag,\n  ) {\n    const res = await this.request<{ [id: string]: `0x${string}` } | null>({\n      method: \"eth_getCurrencies\",\n      params: [address, blockNumberOrHash],\n    });\n    const tokenMap: Record<string, bigint> = {};\n\n    if (res) {\n      for (const [key, value] of Object.entries(res)) {\n        tokenMap[key] = hexToBigInt(value);\n      }\n    }\n\n    return tokenMap;\n  }\n\n  /**\n   * Performs a call to the specified address.\n   * @param callArgs The arguments for the call.\n   * @param callArgs.from The address of the sender.\n   * @param callArgs.to The address of the receiver.\n   * @param callArgs.data The data to be sent.\n   * @param callArgs.value The value to be sent.\n   * @param callArgs.feeCredit The fee credit.\n   * @param blockNumberOrHash The number/hash of the block.\n   * @param overrides The overrides of state for the chain call.\n   */\n  public async call(\n    callArgs: CallArgs,\n    blockNumberOrHash: Hex | BlockTag,\n    overrides?: Record<Address, ContractOverride>,\n  ) {\n    let data: Hex;\n    if (callArgs.abi) {\n      data = encodeFunctionData({\n        abi: callArgs.abi,\n        functionName: callArgs.functionName,\n        args: callArgs.args || [],\n      });\n    } else {\n      data =\n        typeof callArgs.data === \"string\"\n          ? callArgs.data\n          : addHexPrefix(bytesToHex(callArgs.data));\n    }\n    const sendData = {\n      from: callArgs.from || undefined,\n      to: callArgs.to,\n      data: data,\n      value: toHex(callArgs.value || 0n),\n      feeCredit: (callArgs.feeCredit || 5_000_000n).toString(10),\n    };\n\n    const params: unknown[] = [sendData, blockNumberOrHash];\n    if (overrides) {\n      params.push(overrides);\n    }\n\n    const res = await this.request<CallRes>({\n      method: \"eth_call\",\n      params,\n    });\n\n    if (callArgs.abi) {\n      const result = decodeFunctionResult({\n        abi: callArgs.abi,\n        functionName: callArgs.functionName,\n        data: res.data,\n      });\n      return {\n        ...res,\n        decodedData: result,\n      };\n    }\n\n    return res;\n  }\n}\n\nexport { PublicClient };\n","import { mnemonicToSeedSync } from \"@scure/bip39\";\nimport { toHex } from \"../encoding/toHex.js\";\nimport { addHexPrefix } from \"../utils/hex.js\";\nimport type { IPrivateKey } from \"./index.js\";\n\n/**\n * Generate the private key from the mnemonic phrase.\n * @param mnemonic The mnemonic phrase to generate the private key from.\n * @param password The password to generate the private key.\n * @returns The private key.\n */\nconst privateKeyFromPhrase = (mnemonic: string): IPrivateKey => {\n  return addHexPrefix(toHex(mnemonicToSeedSync(mnemonic).slice(0, 32)));\n};\n\nexport { privateKeyFromPhrase };\n","import {\n  bytesToHex,\n  hexToBytes,\n  numberToBytesBE,\n} from \"@noble/curves/abstract/utils\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { poseidonHash } from \"../encoding/poseidon.js\";\nimport { toHex } from \"../encoding/toHex.js\";\nimport type { Hex } from \"../types/Hex.js\";\nimport { assertIsValidShardId } from \"../utils/assert.js\";\nimport { addHexPrefix, removeHexPrefix } from \"../utils/hex.js\";\nimport type { IAddress } from \"./types/IAddress.js\";\nimport type { IPrivateKey } from \"./types/IPrivateKey.js\";\n\n/**\n * Returns the public key from the private key using the secp256k1 curve.\n */\nconst getPublicKey = (privateKey: IPrivateKey, isCompressed = false): Hex => {\n  const publicKey = secp256k1.getPublicKey(\n    removeHexPrefix(privateKey),\n    isCompressed,\n  );\n\n  return addHexPrefix(bytesToHex(publicKey));\n};\n\n/**\n * Returns the address from the public key.\n * @param publicKey The public key in hex format\n * @param shardId The ID of the shard where the address is located.\n * @returns The address in hex format.\n */\nconst getAddressFromPublicKey = (publicKey: Hex, shardId: number): IAddress => {\n  assertIsValidShardId(shardId);\n  const publickKeyWithoutPrefix = removeHexPrefix(publicKey);\n\n  const pubKeyBytes =\n    typeof publickKeyWithoutPrefix === \"string\"\n      ? hexToBytes(publickKeyWithoutPrefix)\n      : publickKeyWithoutPrefix;\n\n  const hash = poseidonHash(pubKeyBytes);\n  const shardPart = numberToBytesBE(shardId, 2);\n  const hashPart = numberToBytesBE(hash, 32);\n  return toHex(new Uint8Array([...shardPart, ...hashPart.slice(14)]));\n};\n\nexport { getPublicKey, getAddressFromPublicKey };\n","import { concatBytes, numberToBytesBE } from \"@noble/curves/abstract/utils\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nimport invariant from \"tiny-invariant\";\nimport { type Hex, bytesToHex, hexToBytes } from \"../index.js\";\nimport { assertIsValidPrivateKey } from \"../utils/assert.js\";\nimport { addHexPrefix, removeHexPrefix } from \"../utils/hex.js\";\nimport { privateKeyFromPhrase } from \"./mnemonic.js\";\nimport { getAddressFromPublicKey, getPublicKey } from \"./publicKey.js\";\nimport type { IAddress } from \"./types/IAddress.js\";\nimport type { ILocalKeySignerConfig } from \"./types/ILocalKeySignerConfig.js\";\nimport type { ISigner } from \"./types/ISigner.js\";\n\n/**\n * The LocalKeySigner is a class that allows for signing data with the private key.\n * It uses the secp256k1 curve implementation by the @noble/curves/secp256k1 library.\n * @example\n * import {\n *   LocalECDSAKeySigner,\n *   generateRandomPrivateKey,\n * } from '@nilfoundation/niljs';\n * const signer = new LocalECDSAKeySigner({\n *   privateKey: generateRandomPrivateKey(),\n * });\n */\nclass LocalECDSAKeySigner implements ISigner {\n  /**\n   * The private key to be used for signing.\n   *\n   * @private\n   * @type {Hex}\n   */\n  private privateKey: Hex;\n  /**\n   * The public key to be used for signing.\n   *\n   * @private\n   * @type {?Hex}\n   */\n  private publicKey?: Hex = undefined;\n  /**\n   * The wallet address.\n   *\n   * @private\n   * @type {?IAddress}\n   */\n  private address?: IAddress = undefined;\n\n  /**\n   * Creates an instance of LocalECDSAKeySigner.\n   *\n   * @constructor\n   * @param {ILocalKeySignerConfig} config The config for the LocalECDSAKeySigner. See {@link ILocalKeySignerConfig}.\n   */\n  constructor(config: ILocalKeySignerConfig) {\n    const { privateKey, mnemonic } = config;\n\n    invariant(\n      privateKey || mnemonic,\n      \"Either privateKey or mnemonic must be provided.\",\n    );\n\n    const privKey = mnemonic\n      ? privateKeyFromPhrase(mnemonic)\n      : addHexPrefix(privateKey as string);\n\n    assertIsValidPrivateKey(privKey);\n\n    this.privateKey = privKey;\n  }\n\n  /**\n   * Signs the data.\n   *\n   * @public\n   * @async\n   * @param {Uint8Array} data The input data.\n   * @returns {Promise<Uint8Array>} The signed data.\n   */\n  public async sign(data: Uint8Array): Promise<Uint8Array> {\n    const signature = secp256k1.sign(data, removeHexPrefix(this.privateKey));\n    const { r, s, recovery } = signature;\n\n    return concatBytes(\n      numberToBytesBE(r, 32),\n      numberToBytesBE(s, 32),\n      numberToBytesBE(recovery, 1),\n    );\n  }\n\n  /**\n   * Retrieves the public key.\n   *\n   * @public\n   * @async\n   * @returns {unknown} The publc key of the signer.\n   */\n  public async getPublicKey() {\n    if (this.publicKey) {\n      return hexToBytes(this.publicKey);\n    }\n\n    const publicKey = getPublicKey(this.privateKey, true);\n\n    this.publicKey = publicKey;\n    return hexToBytes(this.publicKey);\n  }\n\n  /**\n   * Retrieves the wallet address.\n   *\n   * @public\n   * @async\n   * @param {number} shardId The ID of the shard where the wallet is deployed.\n   * @returns {unknown} The wallet address.\n   */\n  public async getAddress(shardId: number) {\n    if (this.address) {\n      return hexToBytes(this.address);\n    }\n\n    const pubKey = await this.getPublicKey();\n\n    this.address = getAddressFromPublicKey(bytesToHex(pubKey), shardId);\n\n    return hexToBytes(this.address);\n  }\n}\n\nexport { LocalECDSAKeySigner };\n","import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { toHex } from \"../encoding/toHex.js\";\nimport type { IPrivateKey } from \"./types/IPrivateKey.js\";\n\n/**\n * Generate a new private key.\n * @returns The new private key\n * @example\n * const privateKey = generatePrivateKey();\n */\nconst generateRandomPrivateKey = (): IPrivateKey =>\n  toHex(secp256k1.utils.randomPrivateKey());\n\nexport { generateRandomPrivateKey };\n","import invariant from \"tiny-invariant\";\nimport type { ISigner } from \"./types/ISigner.js\";\n\n/**\n * The MetaMaskSigner is a class that allows for signing data using MetaMask.\n * This signer can only be used inside a browser.\n * @example\n * import { MetaMaskSigner } from '@nilfoundation/niljs';\n *\n * const signer = new MetaMaskSigner();\n */\nclass MetaMaskSigner implements ISigner {\n  /**\n   * The signer provider.\n   *\n   * @private\n   * @type {*}\n   */\n  private provider;\n  /**\n   * Creates an instance of MetaMaskSigner.\n   *\n   * @constructor\n   */\n  constructor() {\n    invariant(\n      typeof window !== \"undefined\",\n      \"MetaMaskSigner can be used in the browser only\",\n    );\n\n    invariant(\n      typeof window.ethereum !== \"undefined\",\n      \"No MetaMask provider found. Please install MetaMask browser extension before using MetaMaskSigner\",\n    );\n\n    this.provider = window.ethereum;\n  }\n\n  /**\n   * Signs the data.\n   *\n   * @public\n   * @async\n   * @param {Uint8Array} data The input data.\n   * @returns {unknown} The signed data.\n   */\n  public async sign(data: Uint8Array) {\n    // mock signature\n    return new Uint8Array(65);\n  }\n\n  /**\n   * Retrieves the wallet address.\n   *\n   * @public\n   * @async\n   * @returns {unknown}\n   */\n  public async getAddress() {\n    // mock address\n    return new Uint8Array(20);\n  }\n\n  /**\n   * Retreieves the public key.\n   *\n   * @public\n   * @async\n   * @returns {unknown}\n   */\n  public async getPublicKey() {\n    // mock public key\n    return new Uint8Array(33);\n  }\n\n  /**\n   * Connects the signer to an existing MetaMask wallet.\n   *\n   * @public\n   * @async\n   * @returns {Promise<void>}\n   */\n  public async connect(): Promise<void> {\n    await this.provider.request({ method: \"eth_requestAccounts\" });\n  }\n}\n\nexport { MetaMaskSigner };\n","import type { PublicClient } from \"../clients/PublicClient.js\";\nimport type { Hex } from \"../types/Hex.js\";\nimport type { ProcessedReceipt } from \"../types/IReceipt.js\";\n\n/**\n * Makes it so that the client waits until the processing of the message whose hash is passed.\n *\n * @async\n * @param {PublicClient} client The client that must wait for action completion.\n * @param {number} shardId The ID of the shard where the message is processed.\n * @param {Hex} hash The message hash.\n * @returns {unknown}\n * @example\n * await waitTillCompleted(client, 1, hash);\n */\nexport const waitTillCompleted = async (\n  client: PublicClient,\n  shardId: number,\n  hash: Hex,\n  options?: { waitTillMainShard?: boolean, interval?: number }\n) => {\n  const interval = options?.interval || 1000;\n  const waitTillMainShard = options?.waitTillMainShard || true;\n  const receipts: ProcessedReceipt[] = [];\n  const hashes: [number, Hex][] = [[shardId, hash]];\n  let cur = 0;\n  while (cur !== hashes.length) {\n    const [shardId, hash] = hashes[cur];\n    const receipt = await client.getMessageReceiptByHash(hash, shardId);\n    if (!receipt) {\n        await new Promise((resolve) => setTimeout(resolve, interval));\n        continue;\n    }\n    if (receipt.outMessages !== null && receipt.outputReceipts &&\n        receipt.outputReceipts.filter((x) => x !== null).length !==\n        receipt.outMessages.length) {\n        await new Promise((resolve) => setTimeout(resolve, interval));\n        continue;\n    }\n    if (waitTillMainShard && receipt.shardId !== 0 && !receipt.includedInMain) {\n        await new Promise((resolve) => setTimeout(resolve, interval));\n        continue;\n    }\n    cur++;\n    receipts.push(receipt);\n    if (receipt.outputReceipts) {\n      for (const r of receipt.outputReceipts) {\n        if (r !== null) hashes.push([r.shardId, r.messageHash]);\n      }\n    }\n  }\n\n  return receipts;\n};\n","export const convertEthToWei = (eth: number): bigint => {\n  return BigInt(eth * 1e18);\n};\n","import { Client, HTTPTransport, RequestManager } from \"@open-rpc/client-js\";\nimport { version } from \"../version.js\";\n\n/**\n * Creates a new RPC client to interact with the network using the RPC API.\n * The RPC client uses an HTTP transport to send requests to the network.\n * HTTP is currently the only supported transport.\n * @example const client = createRPCClient(RPC_ENDPOINT);\n */\nconst createRPCClient = (endpoint: string) => {\n\tconst transport = new HTTPTransport(endpoint, {\n\t\theaders: {\n\t\t\t\"Client-Version\": version,\n\t\t},\n\t});\n\n\tconst requestManager = new RequestManager([transport]);\n\treturn new Client(requestManager);\n};\n\nexport { createRPCClient };\n","import type { Client as RPCClient } from \"@open-rpc/client-js\";\nimport type { RequestArguments } from \"@open-rpc/client-js/build/ClientInterface.js\";\nimport { createRPCClient } from \"../rpc/rpcClient.js\";\nimport type { IHttpTransportConfig } from \"./types/IHttpTransportConfig.js\";\nimport type { ITransport } from \"./types/ITransport.js\";\n\n/**\n * HttpTransport represents the HTTP transport for connecting to the network.\n *\n * @class HttpTransport\n * @typedef {HttpTransport}\n * @implements {ITransport}\n */\nclass HttpTransport implements ITransport {\n  /**\n   * The RPC client for the transport.\n   *\n   * @private\n   * @type {RPCClient}\n   */\n  private rpcClient: RPCClient;\n  /**\n   * The request timeout.\n   *\n   * @private\n   * @type {number}\n   */\n  private timeout: number;\n\n  /**\n   * Creates an instance of HttpTransport.\n   *\n   * @constructor\n   * @param {IHttpTransportConfig} config The transport config. See {@link IHttpTransportConfig}.\n   */\n  constructor(config: IHttpTransportConfig) {\n    this.rpcClient = createRPCClient(config.endpoint);\n    this.timeout = config.timeout !== undefined ? config.timeout : 20000;\n  }\n\n  /**\n   * Sends a request to the network.\n   *\n   * @public\n   * @async\n   * @template T\n   * @param {RequestArguments} requestObject The request object.\n   * @returns {Promise<T>} The response.\n   */\n  public async request<T>(requestObject: RequestArguments): Promise<T> {\n    return this.rpcClient.request(requestObject, this.timeout);\n  }\n\n  /**\n   * Connects to the network.\n   *\n   * @public\n   */\n  public connect(): void {\n    //\n  }\n\n  /**\n   * Closes the connection to the network.\n   *\n   * @public\n   */\n  public closeConnection(): void {\n    this.rpcClient.close();\n  }\n}\n\nexport { HttpTransport };\n","import type { RequestArguments } from \"@open-rpc/client-js/build/ClientInterface.js\";\nimport invariant from \"tiny-invariant\";\nimport type { IHttpTransportConfig } from \"./types/IHttpTransportConfig.js\";\nimport type { ITransport } from \"./types/ITransport.js\";\n\n/**\n * MetaMask transport represents the MetaMask transport for connecting to the network.\n * MetaMask transport can be used in browser only.\n * @class MetaMaskTransport\n * @typedef {MetaMaskTransport}\n * @implements {ITransport}\n */\nclass MetaMaskTransport implements ITransport {\n  /**\n   * The provider for the transport.\n   *\n   * @private\n   * @type {*}\n   */\n  private provider;\n  /**\n   * The request timeout.\n   *\n   * @private\n   * @type {number}\n   */\n  private timeout: number;\n\n  /**\n   * Creates an instance of MetaMaskTransport.\n   *\n   * @constructor\n   * @param {IHttpTransportConfig} config The transport config.\n   */\n  constructor(config: IHttpTransportConfig) {\n    this.timeout = config.timeout !== undefined ? config.timeout : 20000;\n\n    invariant(\n      typeof window !== \"undefined\",\n      \"MetaMaskTransport can be used in the browser only\",\n    );\n\n    invariant(\n      typeof window.ethereum !== \"undefined\",\n      \"No MetaMask provider found. Please install MetaMask browser extension before using MetaMaskSigner\",\n    );\n\n    this.provider = window.ethereum;\n  }\n\n  /**\n   * Sends a request to the network.\n   *\n   * @public\n   * @async\n   * @template T\n   * @param {RequestArguments} requestObject The request object.\n   * @returns {Promise<T>} The response.\n   */\n  public async request<T>(requestObject: RequestArguments): Promise<T> {\n    return this.provider.request(requestObject);\n  }\n\n  /**\n   * Connects to the network.\n   *\n   * @public\n   */\n  public connect(): void {\n    this.provider.request({ method: \"eth_requestAccounts\" });\n  }\n\n  /**\n   * Closes the connection to the network.\n   *\n   * @public\n   */\n  public closeConnection(): void {\n    //\n  }\n}\n\nexport { MetaMaskTransport };\n","import type { RequestArguments } from \"@open-rpc/client-js/build/ClientInterface.js\";\n\n/**\n * The transport interface.\n */\nabstract class ITransport {\n  /**\n   * Sends a request.\n   * @param requestObject - The request object. It contains the method and parameters.\n   * @returns The response.\n   */\n  abstract request<T>(requestObject: RequestArguments): Promise<T>;\n\n  /**\n   * Connects to the network.\n   */\n  abstract connect(): void;\n\n  /**\n   * Closes the connection to the network.\n   */\n  abstract closeConnection(): void;\n}\n\nexport { ITransport };\n","import { BaseError, type IBaseErrorParameters } from \"./BaseError.js\";\n\n/**\n * The interface for the parameters of the {@link InvalidShardIdError} constructor.\n */\ntype InvalidShardIdErrorParameters = {\n\tshardId?: number;\n} & IBaseErrorParameters;\n\n/**\n * The error class for invalid shard ID.\n * This error is thrown when the provided shard ID is invalid.\n */\nclass InvalidShardIdError extends BaseError {\n\t/**\n\t * Creates an instance of InvalidShardIdError.\n\t *\n\t * @constructor\n\t * @param {InvalidShardIdErrorParameters} param0 The error params.\n\t * @param {*} param0.shardId The invalid shard ID.\n\t * @param {*} param0....rest The remaining error params, see {@link IBaseErrorParameters}.\n\t */\n\tconstructor({ shardId, ...rest }: InvalidShardIdErrorParameters) {\n\t\tsuper(`Expected a valid shardId but got: ${shardId}`, { ...rest });\n\t}\n}\n\nexport { InvalidShardIdError };\n","import { BaseError, type IBaseErrorParameters } from \"./BaseError.js\";\n\n/**\n * The interface for the parameters of the {@link BlockNotFoundError} constructor.\n */\ntype IntegerOutOfRangeErrorParameters = {\n  max?: number | bigint;\n  min: number | bigint;\n  value: number | bigint;\n} & IBaseErrorParameters;\n\n/**\n * The error class for 'integer out of range' errors.\n * This error is thrown when the requested integer is out of range.\n */\nclass IntegerOutOfRangeError extends BaseError {\n  /**\n   * Creates an instance of IntegerOutOfRangeError.\n   *\n   * @constructor\n   * @param {IntegerOutOfRangeErrorParameters} param0 The error params.\n   * @param {*} param0.max The maximum value.\n   * @param {string} param0.min The minimum value.\n   */\n  constructor({ max, min, value, ...rest }: IntegerOutOfRangeErrorParameters) {\n    super(\n      `Number \"${value}\" is not in safe integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n      { ...rest },\n    );\n  }\n}\n\nexport { IntegerOutOfRangeError };\n","import { type Hex, bytesToHex, encodeFunctionData } from \"viem\";\nimport type { PublicClient } from \"../../clients/PublicClient.js\";\nimport { ExternalMessageEnvelope } from \"../../encoding/externalMessage.js\";\nimport { hexToBytes } from \"../../index.js\";\nimport { getShardIdFromAddress } from \"../../utils/address.js\";\nimport { waitTillCompleted } from \"../../utils/receipt.js\";\nimport FaucetCompiled from \"@nilfoundation/smart-contracts/artifacts/Faucet.json\"\n\n/**\n * The Faucet is a special contract that is used to top up other contracts in the =nil; devnet.\n *\n * @class Faucet\n * @typedef {Faucet}\n */\nexport class Faucet {\n  /**\n   * The const address of the Faucet contract.\n   *\n   * @static\n   * @type {\"0x000100000000000000000000000000000FA00CE7\"}\n   */\n  static address = \"0x000100000000000000000000000000000FA00CE7\" as const;\n  /**\n   * The client to be used with the Faucet contract.\n   *\n   * @private\n   * @type {PublicClient}\n   */\n  private client: PublicClient;\n\n  /**\n   * Creates an instance of Faucet.\n   *\n   * @constructor\n   * @param {PublicClient} client\n   */\n  constructor(client: PublicClient) {\n    this.client = client;\n  }\n\n  /**\n   * Withdraws the specified value to the given address.\n   *\n   * @deprecated\n   * @async\n   * @param {Hex} address The address to which the withdrawal should be made.\n   * @param {bigint} [value=1000000000000000000n] The value that should be withdrawn to the given address.\n   * @param {?number} [seqno] The sequence number of the withdrawal message.\n   * @returns {Uint8Array} The hash of the withdrawal message.\n   */\n  async withdrawTo(address: Hex, value = 1000000000000000000n, seqno?: number) {\n    const [refinedSeqno, chainId] = await Promise.all([\n      seqno ?? this.client.getMessageCount(Faucet.address, \"latest\"),\n      this.client.chainId(),\n    ]);\n    const calldata = encodeFunctionData({\n      abi: FaucetCompiled.abi,\n      functionName: \"withdrawTo\",\n      args: [address.toLowerCase(), value],\n    });\n    const message = new ExternalMessageEnvelope({\n      isDeploy: false,\n      to: hexToBytes(Faucet.address),\n      chainId,\n      seqno: refinedSeqno,\n      data: hexToBytes(calldata),\n      authData: new Uint8Array(0),\n    });\n    const encodedMessage = message.encode();\n    await this.client.sendRawMessage(bytesToHex(encodedMessage));\n    return message.hash();\n  }\n\n  /**\n   * Withdraws the specified value to the given address with retries.\n   *\n   * @async\n   * @param {Hex} address The address to which the withdrawal should be made.\n   * @param {bigint} [value=1000000000000000000n] The value that should be withdrawn to the given address.\n   * @param {?number} [retry=3] How many times to retry the withdrawal in case of failure.\n   * @returns {Uint8Array} The hash of the withdrawal message.\n   */\n  async withdrawToWithRetry(\n    address: Hex,\n    value = 1000000000000000000n,\n    retry = 5,\n  ) {\n    let currentRetry = 0;\n    while (currentRetry++ < retry) {\n      try {\n        const [refinedSeqno, chainId] = await Promise.all([\n          this.client.getMessageCount(Faucet.address, \"latest\"),\n          this.client.chainId(),\n        ]);\n        const calldata = encodeFunctionData({\n          abi: FaucetCompiled.abi,\n          functionName: \"withdrawTo\",\n          args: [address.toLowerCase(), value],\n        });\n        const message = new ExternalMessageEnvelope({\n          isDeploy: false,\n          to: hexToBytes(Faucet.address),\n          chainId,\n          seqno: refinedSeqno,\n          data: hexToBytes(calldata),\n          authData: new Uint8Array(0),\n        });\n        const encodedMessage = message.encode();\n        await this.client.sendRawMessage(bytesToHex(encodedMessage));\n        const hash = bytesToHex(message.hash());\n        const receipts = await Promise.race([\n          new Promise<[]>((resolve) => setTimeout(() => resolve([]), 10000)),\n          waitTillCompleted(\n            this.client,\n            getShardIdFromAddress(Faucet.address),\n            hash,\n          ),\n        ]);\n        if (receipts.length === 0) {\n          continue;\n        }\n        if (receipts.some((receipt) => !receipt.success)) {\n          continue;\n        }\n        return hash;\n      } catch (error) {\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n        if (currentRetry >= retry) {\n          throw error;\n        }\n      }\n    }\n    throw new Error(\"Failed to withdraw to the given address\");\n  }\n}\n","import type { Abi } from \"abitype\";\nimport invariant from \"tiny-invariant\";\nimport { bytesToHex, encodeFunctionData } from \"viem\";\nimport type { PublicClient } from \"../../clients/PublicClient.js\";\nimport { prepareDeployPart } from \"../../encoding/deployPart.js\";\nimport { externalMessageEncode } from \"../../encoding/externalMessage.js\";\nimport { hexToBytes } from \"../../encoding/fromHex.js\";\nimport { toHex } from \"../../encoding/toHex.js\";\nimport type { ISigner } from \"../../signers/index.js\";\nimport type { IDeployData } from \"../../types/IDeployData.js\";\nimport { getShardIdFromAddress, refineAddress } from \"../../utils/address.js\";\nimport {\n  refineCompressedPublicKey,\n  refineFunctionHexData,\n  refineSalt,\n} from \"../../utils/refiners.js\";\nimport Wallet from \"@nilfoundation/smart-contracts/artifacts/Wallet.json\";\nimport type {\n  DeployParams,\n  RequestParams,\n  SendMessageParams,\n  SendSyncMessageParams,\n  WalletV1Config,\n} from \"./types/index.js\";\nimport { addHexPrefix } from \"../../index.js\";\n\n/**\n * WalletV1 is a class used for performing operations on the cluster that require authentication.\n *\n * @class WalletV1\n * @typedef {WalletV1}\n */\nexport class WalletV1 {\n  /**\n   * The wallet bytecode.\n   *\n   * @static\n   * @type {*}\n   */\n  static code = hexToBytes(addHexPrefix(Wallet.evm.bytecode.object));\n  /**\n   * The wallet ABI.\n   *\n   * @static\n   * @type {Abi}\n   */\n  static abi = Wallet.abi as Abi;\n\n  /**\n   * Calculates the address of the new wallet.\n   *\n   * @static\n   * @param {{\n   *     pubKey: Uint8Array;\n   *     shardId: number;\n   *     salt: Uint8Array | bigint;\n   *   }} param0 The object representing the config for address calculation.\n   * @param {Uint8Array} param0.pubKey The wallet public key.\n   * @param {number} param0.shardId The ID of the shard where the wallet should be deployed.\n   * @param {Uint8Array | bigint} param0.salt Arbitrary data change the address.\n   * @returns {Uint8Array} The address of the new wallet.\n   * @example\n   * import {\n       LocalECDSAKeySigner,\n       WalletV1,\n       generateRandomPrivateKey,\n     } from '@nilfoundation/niljs';\n\n   * const signer = new LocalECDSAKeySigner({\n       privateKey: generateRandomPrivateKey(),\n     });\n\n     const pubkey = await signer.getPublicKey();\n\n   * const anotherAddress = WalletV1.calculateWalletAddress({\n       pubKey: pubkey,\n       shardId: 1,\n       salt: 200n,\n     });\n   */\n  static calculateWalletAddress({\n    pubKey,\n    shardId,\n    salt,\n  }: {\n    pubKey: Uint8Array;\n    shardId: number;\n    salt: Uint8Array | bigint;\n  }) {\n    const { address } = prepareDeployPart({\n      abi: Wallet.abi as Abi,\n      bytecode: WalletV1.code,\n      args: [bytesToHex(pubKey)],\n      salt: salt,\n      shard: shardId,\n    });\n    return address;\n  }\n\n  /**\n   * The wallet public key.\n   *\n   * @type {Uint8Array}\n   */\n  pubkey: Uint8Array;\n  /**\n   * The ID of the shard where the wallet is deployed.\n   *\n   * @type {number}\n   */\n  shardId: number;\n  /**\n   * The client for interacting with the wallet.\n   *\n   * @type {PublicClient}\n   */\n  client: PublicClient;\n  /**\n   * Arbitrary data for changing the wallet address.\n   *\n   * @type {Uint8Array}\n   */\n  salt?: Uint8Array;\n  /**\n   * The wallet signer.\n   *\n   * @type {ISigner}\n   */\n  signer: ISigner;\n  /**\n   * The wallet address.\n   *\n   * @type {Uint8Array}\n   */\n  address: Uint8Array;\n\n  /**\n   * Creates an instance of WalletV1.\n   *\n   * @constructor\n   * @param {WalletV1Config} param0 The object representing the initial wallet config. See {@link WalletV1Config}.\n   * @param {WalletV1Config} param0.pubkey The wallet public key.\n   * @param {WalletV1Config} param0.shardId The ID of the shard where the wallet is deployed.\n   * @param {WalletV1Config} param0.address The wallet address. If address is not provided it will be calculated with salt.\n   * @param {WalletV1Config} param0.client The client for interacting with the wallet.\n   * @param {WalletV1Config} param0.salt The arbitrary data for changing the wallet address.\n   * @param {WalletV1Config} param0.signer The wallet signer.\n   */\n  constructor({\n    pubkey,\n    shardId,\n    address,\n    client,\n    salt,\n    signer,\n  }: WalletV1Config) {\n    this.pubkey = refineCompressedPublicKey(pubkey);\n    this.client = client;\n    this.signer = signer;\n    invariant(\n      !(salt && address),\n      \"You should use salt and shard for calculating address or address itself, not both to avoid issue.\",\n    );\n    this.address = address\n      ? refineAddress(address)\n      : WalletV1.calculateWalletAddress({\n        pubKey: this.pubkey,\n        shardId,\n        salt,\n      });\n    if (salt) {\n      this.salt = refineSalt(salt);\n    }\n    this.shardId = getShardIdFromAddress(toHex(this.address));\n  }\n\n  /**\n   * Converts the wallet address into a hexadecimal.\n   *\n   * @returns {String}\n   */\n  getAddressHex() {\n    return bytesToHex(this.address);\n  }\n\n  /**\n   * Deploys the wallet.\n   *\n   * @async\n   * @param {boolean} [waitTillConfirmation=true] The flag that determines whether the function waits for deployment confirmation before exiting.\n   * @returns {Uint8Array} The hash of the deployment transaction.\n   * @example\n   * import {\n       Faucet,\n       HttpTransport,\n       LocalECDSAKeySigner,\n       PublicClient,\n       WalletV1,\n       generateRandomPrivateKey,\n     } from '@nilfoundation/niljs';\n   * const client = new PublicClient({\n       transport: new HttpTransport({\n         endpoint: RPC_ENDPOINT,\n       }),\n       shardId: 1,\n     });\n   * const signer = new LocalECDSAKeySigner({\n       privateKey: generateRandomPrivateKey(),\n     });\n   * const faucet = new Faucet(client);\n   * await faucet.withdrawTo(walletAddress, 100000n);\n   * const pubkey = await signer.getPublicKey();\n   * const wallet = new WalletV1({\n       pubkey: pubkey,\n       salt: 100n,\n       shardId: 1,\n       client,\n       signer,\n       address: WalletV1.calculateWalletAddress({\n         pubKey: pubkey,\n         shardId: 1,\n         salt: 100n,\n       }),\n     });\n   * await wallet.selfDeploy(true);\n   */\n  async selfDeploy(waitTillConfirmation = true) {\n    invariant(\n      typeof this.salt !== \"undefined\",\n      \"Salt is required for external deployment. Please provide salt for walelt\",\n    );\n\n    const [balance, code] = await Promise.all([\n      await this.client.getBalance(this.getAddressHex(), \"latest\"),\n      await this.client\n        .getCode(this.getAddressHex(), \"latest\")\n        .catch(() => Uint8Array.from([])),\n    ]);\n\n    invariant(code.length === 0, \"Contract already deployed\");\n    invariant(balance > 0n, \"Insufficient balance\");\n\n    const { data } = prepareDeployPart({\n      abi: Wallet.abi as Abi,\n      bytecode: WalletV1.code,\n      args: [bytesToHex(this.pubkey)],\n      salt: this.salt,\n      shard: this.shardId,\n    });\n\n    const { hash } = await this.requestToWallet({\n      data: data,\n      deploy: true,\n      seqno: 0,\n    });\n\n    if (waitTillConfirmation) {\n      while (true) {\n        const code = await this.client.getCode(this.getAddressHex(), \"latest\");\n        if (code.length > 0) {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n    }\n    return hash;\n  }\n\n  /**\n   * Checks the deployment status.\n   *\n   * @async\n   * @returns {Promise<boolean>} The current deployment status.\n   */\n  async checkDeploymentStatus(): Promise<boolean> {\n    const code = await this.client.getCode(this.getAddressHex(), \"latest\");\n    return code.length > 0;\n  }\n\n  /**\n   * Performs a request to the wallet.\n   *\n   * @async\n   * @param {RequestParams} requestParams The object representing the request parameters.\n   * @param {boolean} [send=true] The flag that determines whether the request is sent when the function is called.\n   * @returns {Promise<{ raw: Uint8Array; hash: Uint8Array }>} The message bytecode and hash.\n   */\n  async requestToWallet(\n    requestParams: RequestParams,\n    send = true,\n  ): Promise<{ raw: Uint8Array; hash: Uint8Array }> {\n    const [seqno, chainId] = await Promise.all([\n      requestParams.seqno ??\n      this.client.getMessageCount(this.getAddressHex(), \"latest\"),\n      requestParams.chainId ?? this.client.chainId(),\n    ]);\n    const encodedMessage = await externalMessageEncode(\n      {\n        isDeploy: requestParams.deploy,\n        to: this.address,\n        chainId: chainId,\n        seqno,\n        data: requestParams.data,\n      },\n      this.signer,\n    );\n    if (send) await this.client.sendRawMessage(encodedMessage.raw);\n    return encodedMessage;\n  }\n\n  /**\n   * Send a message via the wallet.\n   *\n   * @async\n   * @param {SendMessageParams} param0 The object representing the message params.\n   * @param {SendMessageParams} param0.to The address where the message should be sent.\n   * @param {SendMessageParams} param0.refundTo The address where the gas cost should be refunded.\n   * @param {SendMessageParams} param0.bounceTo The address where the message value should be refunded in case of failure.\n   * @param {SendMessageParams} param0.tokens The tokens to be sent with the message.\n   * @param {SendMessageParams} param0.data The message bytecode.\n   * @param {SendMessageParams} param0.abi The message abi for encoding.\n   * @param {SendMessageParams} param0.functionName The message function name for abi.\n   * @param {SendMessageParams} param0.args The message args name for abi.\n   * @param {SendMessageParams} param0.deploy The flag that determines whether the message is a deploy message.\n   * @param {SendMessageParams} param0.seqno The message sequence number.\n   * @param {SendMessageParams} param0.feeCredit The message fee credit for processing message on receiving shard.\n   * @param {SendMessageParams} param0.value The message value.\n   * @param {SendMessageParams} param0.chainId The message chain id.\n   * @returns {unknown} The message hash.\n   * @example\n   * const anotherAddress = WalletV1.calculateWalletAddress({\n   *     pubKey: pubkey,\n   *     shardId: 1,\n   *     salt: 200n,\n   *   });\n   * await wallet.sendMessage({\n   *     to: anotherAddress,\n   *     value: 10n,\n   *     gas: 100000n,\n   *   });\n   */\n  async sendMessage({\n    to,\n    refundTo,\n    bounceTo,\n    data,\n    abi,\n    functionName,\n    args,\n    deploy,\n    seqno,\n    feeCredit,\n    value,\n    tokens,\n    chainId,\n  }: SendMessageParams) {\n    const hexTo = bytesToHex(refineAddress(to));\n    const hexRefundTo = bytesToHex(refineAddress(refundTo ?? this.address));\n    const hexBounceTo = bytesToHex(refineAddress(bounceTo ?? this.address));\n    const hexData = refineFunctionHexData({ data, abi, functionName, args });\n\n    const callData = encodeFunctionData({\n      abi: Wallet.abi,\n      functionName: \"asyncCall\",\n      args: [\n        hexTo,\n        hexRefundTo,\n        hexBounceTo,\n        feeCredit,\n        !!deploy,\n        tokens ?? [],\n        value ?? 0n,\n        hexData,\n      ],\n    });\n\n    const { hash } = await this.requestToWallet({\n      data: hexToBytes(callData),\n      deploy: false,\n      seqno,\n      chainId,\n    });\n\n    return bytesToHex(hash);\n  }\n\n  /**\n   * Sets the name of the custom currency that the wallet can own and mint.\n   *\n   * @async\n   * @param {string} The name of the custom currency.\n   * @returns {unknown} The message hash.\n   * @example\n   * const hashMessage = await wallet.setCurrencyName(\"MY_TOKEN\");\n   * await waitTillCompleted(client, 1, hashMessage);\n   */\n  async setCurrencyName(name: string) {\n    const callData = encodeFunctionData({\n      abi: Wallet.abi,\n      functionName: \"setCurrencyName\",\n      args: [name],\n    });\n\n    const { hash } = await this.requestToWallet({\n      data: hexToBytes(callData),\n      deploy: false,\n    });\n\n    return bytesToHex(hash);\n  }\n\n  /**\n   * Mints the currency that the wallet owns and withdraws it to the wallet.\n   * {@link setCurrencyName} has to be called first before minting a currency.\n   *\n   * @async\n   * @param {bigint} The amount to mint.\n   * @returns {unknown} The message hash.\n   * @example\n   * const hashMessage = await wallet.mintCurrency(mintCount);\n   * await waitTillCompleted(client, 1, hashMessage);\n   */\n  async mintCurrency(amount: bigint) {\n    return await this.changeCurrencyAmount(amount, true);\n  }\n\n  /**\n   * Burns the currency that the wallet owns.\n   *\n   * @async\n   * @param {bigint} The amount to burn.\n   * @returns {unknown} The message hash.\n   * @example\n   * const hashMessage = await wallet.burnCurrency(burnCurrency);\n   * await waitTillCompleted(client, 1, hashMessage);\n   */\n  async burnCurrency(amount: bigint) {\n    return await this.changeCurrencyAmount(amount, false);\n  }\n\n  private async changeCurrencyAmount(amount: bigint, mint: boolean) {\n    let method = \"burnCurrency\";\n    if (mint) {\n      method = \"mintCurrency\";\n    }\n\n    const callData = encodeFunctionData({\n      abi: Wallet.abi,\n      functionName: method,\n      args: [amount],\n    });\n\n    const { hash } = await this.requestToWallet({\n      data: hexToBytes(callData),\n      deploy: false,\n    });\n\n    return bytesToHex(hash);\n  }\n\n  /**\n   * Send a raw signed message via the wallet.\n   *\n   * @async\n   * @param {Uint8Array} rawMessage The message bytecode.\n   * @returns {unknown} The message hash.\n   */\n  async sendRawInternalMessage(rawMessage: Uint8Array) {\n    const { hash } = await this.requestToWallet({\n      data: rawMessage,\n      deploy: false,\n    });\n\n    return bytesToHex(hash);\n  }\n\n  /**\n   * Deploys a new smart contract via the wallet.\n   *\n   * @async\n   * @param {DeployParams} param0 The object representing the contract deployment params.\n   * @param {DeployParams} param0.shardId The ID of the shard where the contract should be deployed.\n   * @param {DeployParams} param0.bytecode The contract bytecode.\n   * @param {DeployParams} param0.abi The contract ABI.\n   * @param {DeployParams} param0.args The arbitrary arguments for deployment.\n   * @param {DeployParams} param0.salt The arbitrary data for changing the contract address.\n   * @param {DeployParams} param0.value The deployment message value.\n   * @param {DeployParams} param0.feeCredit The deployment message fee credit.\n   * @param {DeployParams} param0.seqno The deployment message seqno.\n   * @param {DeployParams} param0.chainId The deployment message chain id.\n   * @returns {unknown} The object containing the deployment message hash and the contract address.\n   */\n  async deployContract({\n    shardId,\n    bytecode,\n    abi,\n    args,\n    salt,\n    value,\n    feeCredit,\n    seqno,\n    chainId,\n  }: DeployParams) {\n    let deployData: IDeployData;\n    if (abi && args) {\n      deployData = {\n        shard: shardId,\n        bytecode,\n        abi: abi,\n        args: args,\n        salt,\n      };\n    } else {\n      invariant(\n        !(abi || args),\n        \"ABI and args should be provided together or not provided at all.\",\n      );\n      deployData = {\n        shard: shardId,\n        bytecode,\n        salt,\n      };\n    }\n\n    const { data, address } = prepareDeployPart(deployData);\n\n    const hash = await this.sendMessage({\n      to: address,\n      refundTo: this.getAddressHex(),\n      data,\n      value: value ?? 0n,\n      deploy: true,\n      feeCredit,\n      seqno,\n      chainId,\n    });\n\n    return {\n      hash,\n      address: bytesToHex(address),\n    };\n  }\n\n  /**\n   * Creates a new message and performs a synchronous call to the specified address.\n   *\n   * @async\n   * @param {SendSyncMessageParams} param0 The object representing the message params.\n   * @param {SendSyncMessageParams} param0.to The address where the message should be sent.\n   * @param {SendSyncMessageParams} param0.data The message bytecode.\n   * @param {SendSyncMessageParams} param0.abi The message abi.\n   * @param {SendSyncMessageParams} param0.functionName The message function name for abi.\n   * @param {SendSyncMessageParams} param0.args The message args for abi.\n   * @param {SendMessageParams} param0.seqno The message sequence number.\n   * @param {SendMessageParams} param0.gas The message gas.\n   * @param {SendMessageParams} param0.value The message value.\n   * @returns {unknown} The message hash.\n   * @example\n   * const anotherAddress = WalletV1.calculateWalletAddress({\n   *     pubKey: pubkey,\n   *     shardId: 1,\n   *     salt: 200n,\n   *   });\n   * await wallet.sendMessage({\n   *     to: anotherAddress,\n   *     value: 10n,\n   *     gas: 100000n,\n   *   });\n   */\n  async syncSendMessage({\n    to,\n    data,\n    abi,\n    functionName,\n    args,\n    seqno,\n    gas,\n    value,\n  }: SendSyncMessageParams) {\n    const hexTo = bytesToHex(refineAddress(to));\n    const hexData = refineFunctionHexData({ data, abi, functionName, args });\n\n    const callData = encodeFunctionData({\n      abi: Wallet.abi,\n      functionName: \"syncCall\",\n      args: [hexTo, gas, value, hexData],\n    });\n\n    const { hash } = await this.requestToWallet({\n      data: hexToBytes(callData),\n      deploy: false,\n      seqno,\n    });\n\n    return bytesToHex(hash);\n  }\n\n  /**\n   * Returns the wallet balance.\n   *\n   * @async\n   * @returns {unknown} The wallet balance.\n   */\n  async getBalance() {\n    return this.client.getBalance(this.getAddressHex(), \"latest\");\n  }\n}\n"],"names":["version","pkgJson","s$3","BaseError","message","isOperational","cause","docsPath","HEX_REGEX","isHexString","value","removeHexPrefix","str","addHexPrefix","concatHex","values","acc","x","charCodeToBase16","charCode","hexToNumber","hex","hexToBigInt","hexToBytes","hexString","length","bytes","index","j","nibbleLeft","nibbleRight","hexes","_","i","stringToHex","bytesToHex","numberToHex","num","maxValue","minValue","IntegerOutOfRangeError","toHex","decoder","bytesToString","poseidon","pkg","poseidonHash","setHasher","a","b","hash","concatBytes","arr","hashObjectToUint8Array","uint8ArrayToHashObject","basicTypes","UintNumberType","UintBigintType","BooleanType","Bytes20","ByteVectorType","SszMessageSchema","ContainerType","ByteListType","SszSignedMessageSchema","ADDRESS_REGEX","isAddress","getShardIdFromAddress","address","calculateAddress","shardId","code","salt","shardPart","numberToBytesBE","hashPart","refineAddress","refineSalt","invariant","refineCompressedPublicKey","pubkey","res","refineFunctionHexData","data","abi","functionName","args","encodeFunctionData","prepareDeployPart","byteSalt","constructorData","encodeDeployData","bytecode","ExternalMessageEnvelope","isDeploy","to","chainId","seqno","authData","raw","signer","signature","client","InternalMessageEnvelope","externalDeploymentMessage","deployData","externalMessageEncode","params","t$2","blockNumberOrHash","rest","masterShardId","isValidBlock","block","assertIsHexString","assertIsBuffer","assertIsValidPrivateKey","privateKey","assertIsValidDeployData","deployContractData","assertIsValidShardId","assertIsAddress","assertIsValidBlock","InvalidShardIdError","e$1","config","requestObject","PublicClient","BaseClient","fullTx","error","BlockNotFoundError","blockNumber","mapReceipt","receipt","price","tokenMap","key","callArgs","overrides","result","decodeFunctionResult","privateKeyFromPhrase","mnemonic","mnemonicToSeedSync","getPublicKey","isCompressed","publicKey","secp256k1","getAddressFromPublicKey","publickKeyWithoutPrefix","pubKeyBytes","LocalECDSAKeySigner","privKey","r","s","recovery","pubKey","generateRandomPrivateKey","waitTillCompleted","options","interval","waitTillMainShard","receipts","hashes","cur","resolve","convertEthToWei","eth","createRPCClient","endpoint","transport","HTTPTransport","requestManager","RequestManager","Client","r$1","MetaMaskTransport","ITransport","max","min","_Faucet","refinedSeqno","calldata","FaucetCompiled","encodedMessage","retry","currentRetry","Faucet","_WalletV1","Wallet","waitTillConfirmation","balance","requestParams","send","refundTo","bounceTo","deploy","feeCredit","tokens","hexTo","hexRefundTo","hexBounceTo","hexData","callData","name","amount","mint","method","rawMessage","gas","WalletV1"],"mappings":"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"}